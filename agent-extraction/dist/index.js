// @bun
var _3=Object.defineProperty;var G3=($,W)=>{for(var J in W)_3($,J,{get:W[J],enumerable:!0,configurable:!0,set:(Q)=>W[J]=()=>Q})};function i$($){let W=$,J=0;while(J<W.length){let Q=W.indexOf("http://",J),X=W.indexOf("https://",J),Y=-1,_=0;if(Q===-1&&X===-1)break;if(Q!==-1&&(X===-1||Q<X))Y=Q,_=7;else Y=X,_=8;let G=Y+_,H=W.indexOf("@",G),N=G;while(N<W.length){let j=W[N];if(/[\s"'`<>,;{}[\]]/.test(j))break;N++}if(H!==-1&&H<N)W=`${W.substring(0,G)}******${W.substring(H)}`,J=G+6;else J=Y+_}return W}function X$($){if(typeof $==="string")return i$($);if($===null||$===void 0)return $;if(Array.isArray($))return $.map((W)=>X$(W));if(typeof $==="object"){let W={};for(let[J,Q]of Object.entries($))W[J]=X$(Q);return W}return $}class y${baseLogger;constructor($){this.baseLogger=$}sanitizeContext($){return $?X$($):$}sanitizeError($){if(!$)return $;let W=Error(i$($.message));if(W.name=$.name,$.stack)W.stack=i$($.stack);let J=W,Q=$;for(let X of Object.keys($))if(X!=="message"&&X!=="stack"&&X!=="name")J[X]=X$(Q[X]);return W}debug($,W){this.baseLogger.debug($,this.sanitizeContext(W))}info($,W){this.baseLogger.info($,this.sanitizeContext(W))}warn($,W){this.baseLogger.warn($,this.sanitizeContext(W))}error($,W,J){this.baseLogger.error($,this.sanitizeError(W),this.sanitizeContext(J))}child($){let W=X$($),J=this.baseLogger.child(W);return new y$(J)}}var g;(function($){$[$.DEBUG=0]="DEBUG",$[$.INFO=1]="INFO",$[$.WARN=2]="WARN",$[$.ERROR=3]="ERROR"})(g||(g={}));var h={reset:"\x1B[0m",debug:"\x1B[36m",info:"\x1B[32m",warn:"\x1B[33m",error:"\x1B[31m",dim:"\x1B[2m"};class g${baseContext;minLevel;pretty;constructor($,W=g.INFO,J=!1){this.baseContext=$,this.minLevel=W,this.pretty=J}debug($,W){if(this.shouldLog(g.DEBUG)){let J=this.buildLogData("debug",$,W);this.output(console.log,J)}}info($,W){if(this.shouldLog(g.INFO)){let J=this.buildLogData("info",$,W);this.output(console.log,J)}}warn($,W){if(this.shouldLog(g.WARN)){let J=this.buildLogData("warn",$,W);this.output(console.warn,J)}}error($,W,J){if(this.shouldLog(g.ERROR)){let Q=this.buildLogData("error",$,J,W);this.output(console.error,Q)}}child($){return new g$({...this.baseContext,...$},this.minLevel,this.pretty)}shouldLog($){return $>=this.minLevel}buildLogData($,W,J,Q){let X={level:$,msg:W,...this.baseContext,...J,timestamp:new Date().toISOString()};if(Q)X.error={message:Q.message,stack:Q.stack,name:Q.name};return X}output($,W){if(this.pretty)this.outputPretty($,W);else this.outputJson($,W)}outputJson($,W){$(JSON.stringify(W))}outputPretty($,W){let{level:J,msg:Q,timestamp:X,traceId:Y,component:_,sandboxId:G,sessionId:H,processId:N,commandId:j,operation:V,duration:D,error:S,...E}=W,w=String(J||"INFO").toUpperCase(),F=this.getLevelColor(w),x=_?`[${_}]`:"",v=Y?String(Y).substring(0,12):"",P=`${F}${w.padEnd(5)}${h.reset} ${x} ${Q}`;if(v)P+=` ${h.dim}(trace: ${v})${h.reset}`;let C=[];if(V)C.push(`operation: ${V}`);if(j)C.push(`commandId: ${String(j).substring(0,12)}`);if(G)C.push(`sandboxId: ${G}`);if(H)C.push(`sessionId: ${String(H).substring(0,12)}`);if(N)C.push(`processId: ${N}`);if(D!==void 0)C.push(`duration: ${D}ms`);if(C.length>0)P+=` ${h.dim}{${C.join(", ")}}${h.reset}`;if($(P),S&&typeof S==="object"){let A=S;if(A.message)$(`  ${h.error}Error: ${A.message}${h.reset}`);if(A.stack)$(`  ${h.dim}${A.stack}${h.reset}`)}if(Object.keys(E).length>0)$(`  ${h.dim}${JSON.stringify(E,null,2)}${h.reset}`)}getLevelColor($){switch($.toLowerCase()){case"debug":return h.debug;case"info":return h.info;case"warn":return h.warn;case"error":return h.error;default:return h.reset}}}class a{static TRACE_HEADER="X-Trace-Id";static generate(){return`tr_${crypto.randomUUID().replace(/-/g,"").substring(0,16)}`}static fromHeaders($){return $.get(a.TRACE_HEADER)}static toHeaders($){return{[a.TRACE_HEADER]:$}}static getHeaderName(){return a.TRACE_HEADER}}function n$(){return{debug:()=>{},info:()=>{},warn:()=>{},error:()=>{},child:()=>n$()}}function N$($){let W=H3(),J=B3(),Q={...$,traceId:$.traceId||a.generate(),component:$.component};return new g$(Q,W,J)}function H3(){switch((IW("SANDBOX_LOG_LEVEL")||"info").toLowerCase()){case"debug":return g.DEBUG;case"info":return g.INFO;case"warn":return g.WARN;case"error":return g.ERROR;default:return g.INFO}}function B3(){let $=IW("SANDBOX_LOG_FORMAT");if($)return $.toLowerCase()==="pretty";return!1}function IW($){if(typeof process<"u"&&process.env)return process.env[$];if(typeof Bun<"u"){let W=Bun.env;if(W)return W[$]}return}function I($){return`'${$.replace(/'/g,"'\\''")}'`}var{serve:a8}=globalThis.Bun;var B={FILE_NOT_FOUND:"FILE_NOT_FOUND",PERMISSION_DENIED:"PERMISSION_DENIED",FILE_EXISTS:"FILE_EXISTS",IS_DIRECTORY:"IS_DIRECTORY",NOT_DIRECTORY:"NOT_DIRECTORY",NO_SPACE:"NO_SPACE",TOO_MANY_FILES:"TOO_MANY_FILES",RESOURCE_BUSY:"RESOURCE_BUSY",READ_ONLY:"READ_ONLY",NAME_TOO_LONG:"NAME_TOO_LONG",TOO_MANY_LINKS:"TOO_MANY_LINKS",FILESYSTEM_ERROR:"FILESYSTEM_ERROR",COMMAND_NOT_FOUND:"COMMAND_NOT_FOUND",COMMAND_PERMISSION_DENIED:"COMMAND_PERMISSION_DENIED",INVALID_COMMAND:"INVALID_COMMAND",COMMAND_EXECUTION_ERROR:"COMMAND_EXECUTION_ERROR",STREAM_START_ERROR:"STREAM_START_ERROR",PROCESS_NOT_FOUND:"PROCESS_NOT_FOUND",PROCESS_PERMISSION_DENIED:"PROCESS_PERMISSION_DENIED",PROCESS_ERROR:"PROCESS_ERROR",PORT_ALREADY_EXPOSED:"PORT_ALREADY_EXPOSED",PORT_IN_USE:"PORT_IN_USE",PORT_NOT_EXPOSED:"PORT_NOT_EXPOSED",INVALID_PORT_NUMBER:"INVALID_PORT_NUMBER",INVALID_PORT:"INVALID_PORT",SERVICE_NOT_RESPONDING:"SERVICE_NOT_RESPONDING",PORT_OPERATION_ERROR:"PORT_OPERATION_ERROR",CUSTOM_DOMAIN_REQUIRED:"CUSTOM_DOMAIN_REQUIRED",GIT_REPOSITORY_NOT_FOUND:"GIT_REPOSITORY_NOT_FOUND",GIT_BRANCH_NOT_FOUND:"GIT_BRANCH_NOT_FOUND",GIT_AUTH_FAILED:"GIT_AUTH_FAILED",GIT_NETWORK_ERROR:"GIT_NETWORK_ERROR",INVALID_GIT_URL:"INVALID_GIT_URL",GIT_CLONE_FAILED:"GIT_CLONE_FAILED",GIT_CHECKOUT_FAILED:"GIT_CHECKOUT_FAILED",GIT_OPERATION_FAILED:"GIT_OPERATION_FAILED",BUCKET_MOUNT_ERROR:"BUCKET_MOUNT_ERROR",S3FS_MOUNT_ERROR:"S3FS_MOUNT_ERROR",MISSING_CREDENTIALS:"MISSING_CREDENTIALS",INVALID_MOUNT_CONFIG:"INVALID_MOUNT_CONFIG",INTERPRETER_NOT_READY:"INTERPRETER_NOT_READY",CONTEXT_NOT_FOUND:"CONTEXT_NOT_FOUND",CODE_EXECUTION_ERROR:"CODE_EXECUTION_ERROR",PYTHON_NOT_AVAILABLE:"PYTHON_NOT_AVAILABLE",VALIDATION_FAILED:"VALIDATION_FAILED",INVALID_JSON_RESPONSE:"INVALID_JSON_RESPONSE",UNKNOWN_ERROR:"UNKNOWN_ERROR",INTERNAL_ERROR:"INTERNAL_ERROR"};var ZW={[B.FILE_NOT_FOUND]:404,[B.COMMAND_NOT_FOUND]:404,[B.PROCESS_NOT_FOUND]:404,[B.PORT_NOT_EXPOSED]:404,[B.GIT_REPOSITORY_NOT_FOUND]:404,[B.GIT_BRANCH_NOT_FOUND]:404,[B.CONTEXT_NOT_FOUND]:404,[B.IS_DIRECTORY]:400,[B.NOT_DIRECTORY]:400,[B.INVALID_COMMAND]:400,[B.INVALID_PORT_NUMBER]:400,[B.INVALID_PORT]:400,[B.INVALID_GIT_URL]:400,[B.CUSTOM_DOMAIN_REQUIRED]:400,[B.INVALID_JSON_RESPONSE]:400,[B.NAME_TOO_LONG]:400,[B.VALIDATION_FAILED]:400,[B.MISSING_CREDENTIALS]:400,[B.INVALID_MOUNT_CONFIG]:400,[B.GIT_AUTH_FAILED]:401,[B.PERMISSION_DENIED]:403,[B.COMMAND_PERMISSION_DENIED]:403,[B.PROCESS_PERMISSION_DENIED]:403,[B.READ_ONLY]:403,[B.FILE_EXISTS]:409,[B.PORT_ALREADY_EXPOSED]:409,[B.PORT_IN_USE]:409,[B.RESOURCE_BUSY]:409,[B.SERVICE_NOT_RESPONDING]:502,[B.GIT_NETWORK_ERROR]:502,[B.PYTHON_NOT_AVAILABLE]:501,[B.INTERPRETER_NOT_READY]:503,[B.NO_SPACE]:500,[B.TOO_MANY_FILES]:500,[B.TOO_MANY_LINKS]:500,[B.FILESYSTEM_ERROR]:500,[B.COMMAND_EXECUTION_ERROR]:500,[B.STREAM_START_ERROR]:500,[B.PROCESS_ERROR]:500,[B.PORT_OPERATION_ERROR]:500,[B.GIT_CLONE_FAILED]:500,[B.GIT_CHECKOUT_FAILED]:500,[B.GIT_OPERATION_FAILED]:500,[B.CODE_EXECUTION_ERROR]:500,[B.BUCKET_MOUNT_ERROR]:500,[B.S3FS_MOUNT_ERROR]:500,[B.UNKNOWN_ERROR]:500,[B.INTERNAL_ERROR]:500};function QW($){return ZW[$]||500}function XW($,W){switch($){case B.FILE_NOT_FOUND:return`Ensure the file exists at ${W.path} before attempting to access it`;case B.FILE_EXISTS:return`File already exists at ${W.path}. Use a different path or delete the existing file first`;case B.COMMAND_NOT_FOUND:return`Check that "${W.command}" is installed and available in the system PATH`;case B.PROCESS_NOT_FOUND:return"Verify the process ID is correct and the process has not already exited";case B.PORT_NOT_EXPOSED:return`Port ${W.port} is not currently exposed. Use listExposedPorts() to see active ports`;case B.PORT_ALREADY_EXPOSED:return`Port ${W.port} is already exposed. Unexpose it first or use a different port`;case B.PORT_IN_USE:return`Port ${W.port} is already in use by another service. Choose a different port`;case B.INVALID_PORT:return`Port must be between 1 and 65535. Port ${W.port} is ${W.reason}`;case B.GIT_REPOSITORY_NOT_FOUND:return"Verify the repository URL is correct and accessible";case B.GIT_AUTH_FAILED:return"Check authentication credentials or use a public repository";case B.GIT_BRANCH_NOT_FOUND:return`Branch "${W.branch}" does not exist in the repository. Check the branch name or use the default branch`;case B.INTERPRETER_NOT_READY:return W.retryAfter?`Code interpreter is starting up. Retry after ${W.retryAfter} seconds`:"Code interpreter is not ready. Please wait a moment and try again";case B.CONTEXT_NOT_FOUND:return`Context "${W.contextId}" does not exist. Create a context first using createContext()`;case B.VALIDATION_FAILED:return"Check the request parameters and ensure they match the required format";case B.NO_SPACE:return"Not enough disk space available. Consider cleaning up temporary files or increasing storage";case B.PERMISSION_DENIED:return"Operation not permitted. Check file/directory permissions";case B.IS_DIRECTORY:return`Cannot perform this operation on a directory. Path ${W.path} is a directory`;case B.NOT_DIRECTORY:return`Expected a directory but found a file at ${W.path}`;case B.RESOURCE_BUSY:return"Resource is currently in use. Wait for the current operation to complete";case B.READ_ONLY:return"Cannot modify a read-only resource";case B.SERVICE_NOT_RESPONDING:return"Service is not responding. Check if the service is running and accessible";default:return}}var f={FILE_READ:"file.read",FILE_WRITE:"file.write",FILE_DELETE:"file.delete",FILE_MOVE:"file.move",FILE_RENAME:"file.rename",FILE_STAT:"file.stat",DIRECTORY_CREATE:"directory.create",DIRECTORY_LIST:"directory.list",COMMAND_EXECUTE:"command.execute",COMMAND_STREAM:"command.stream",PROCESS_START:"process.start",PROCESS_KILL:"process.kill",PROCESS_LIST:"process.list",PROCESS_GET:"process.get",PROCESS_LOGS:"process.logs",PORT_EXPOSE:"port.expose",PORT_UNEXPOSE:"port.unexpose",PORT_LIST:"port.list",PORT_PROXY:"port.proxy",GIT_CLONE:"git.clone",GIT_CHECKOUT:"git.checkout",GIT_OPERATION:"git.operation",CODE_EXECUTE:"code.execute",CODE_CONTEXT_CREATE:"code.context.create",CODE_CONTEXT_DELETE:"code.context.delete"};class Z{logger;constructor($){this.logger=$}createTypedResponse($,W,J=200){return new Response(JSON.stringify($),{status:J,headers:{"Content-Type":"application/json",...W.corsHeaders}})}createErrorResponse($,W,J){let Q=this.enrichServiceError($,J);return new Response(JSON.stringify(Q),{status:Q.httpStatus,headers:{"Content-Type":"application/json",...W.corsHeaders}})}enrichServiceError($,W){let J=$.code;return{code:J,message:$.message,context:$.details||{},operation:W||$.details?.operation,httpStatus:QW(J),timestamp:new Date().toISOString(),suggestion:XW(J,$.details||{})}}async parseRequestBody($){try{return await $.json()}catch(W){throw Error(`Failed to parse request body: ${W instanceof Error?W.message:"Invalid JSON"}`)}}extractPathParam($,W){return $.split("/")[W]||""}extractQueryParam($,W){return new URL($.url).searchParams.get(W)}extractTraceId($){return a.fromHeaders($.headers)}createRequestLogger($,W){let J=this.extractTraceId($),Q={};if(J)Q.traceId=J;if(W)Q.operation=W;return Q.traceId||Q.operation?this.logger.child(Q):this.logger}}class YW extends Z{processService;constructor($,W){super(W);this.processService=$}async handle($,W){switch(new URL($.url).pathname){case"/api/execute":return await this.handleExecute($,W);case"/api/execute/stream":return await this.handleStreamingExecute($,W);default:return this.createErrorResponse({message:"Invalid execute endpoint",code:B.UNKNOWN_ERROR},W)}}async handleExecute($,W){let J=await this.parseRequestBody($),Q=J.sessionId||W.sessionId;if(J.background){let G=await this.processService.startProcess(J.command,{sessionId:Q,timeoutMs:J.timeoutMs,env:J.env,cwd:J.cwd});if(!G.success)return this.createErrorResponse(G.error,W);let H=G.data,N={success:!0,processId:H.id,pid:H.pid,command:J.command,timestamp:new Date().toISOString()};return this.createTypedResponse(N,W)}let X=await this.processService.executeCommand(J.command,{sessionId:Q,timeoutMs:J.timeoutMs,env:J.env,cwd:J.cwd});if(!X.success)return this.createErrorResponse(X.error,W);let Y=X.data,_={success:Y.success,exitCode:Y.exitCode,stdout:Y.stdout,stderr:Y.stderr,command:J.command,duration:0,timestamp:new Date().toISOString(),sessionId:Q};return this.createTypedResponse(_,W)}async handleStreamingExecute($,W){let J=await this.parseRequestBody($),Q=J.sessionId||W.sessionId,X=await this.processService.startProcess(J.command,{sessionId:Q,env:J.env,cwd:J.cwd});if(!X.success)return this.createErrorResponse(X.error,W);let Y=X.data,_=new ReadableStream({start(G){let H=`data: ${JSON.stringify({type:"start",command:Y.command,timestamp:new Date().toISOString()})}

`;if(G.enqueue(new TextEncoder().encode(H)),Y.stdout){let V=`data: ${JSON.stringify({type:"stdout",data:Y.stdout,timestamp:new Date().toISOString()})}

`;G.enqueue(new TextEncoder().encode(V))}if(Y.stderr){let V=`data: ${JSON.stringify({type:"stderr",data:Y.stderr,timestamp:new Date().toISOString()})}

`;G.enqueue(new TextEncoder().encode(V))}let N=(V,D)=>{let S=`data: ${JSON.stringify({type:V,data:D,timestamp:new Date().toISOString()})}

`;G.enqueue(new TextEncoder().encode(S))},j=(V)=>{if(["completed","failed","killed","error"].includes(V)){let D=`data: ${JSON.stringify({type:"complete",exitCode:Y.exitCode,timestamp:new Date().toISOString()})}

`;G.enqueue(new TextEncoder().encode(D)),G.close()}};if(Y.outputListeners.add(N),Y.statusListeners.add(j),["completed","failed","killed","error"].includes(Y.status)){let V=`data: ${JSON.stringify({type:"complete",exitCode:Y.exitCode,timestamp:new Date().toISOString()})}

`;G.enqueue(new TextEncoder().encode(V)),G.close()}return()=>{Y.outputListeners.delete(N),Y.statusListeners.delete(j)}}});return new Response(_,{status:200,headers:{"Content-Type":"text/event-stream","Cache-Control":"no-cache",Connection:"keep-alive",...W.corsHeaders}})}}class _W extends Z{fileService;constructor($,W){super(W);this.fileService=$}async handle($,W){switch(new URL($.url).pathname){case"/api/read":return await this.handleRead($,W);case"/api/read/stream":return await this.handleReadStream($,W);case"/api/write":return await this.handleWrite($,W);case"/api/delete":return await this.handleDelete($,W);case"/api/rename":return await this.handleRename($,W);case"/api/move":return await this.handleMove($,W);case"/api/mkdir":return await this.handleMkdir($,W);case"/api/list-files":return await this.handleListFiles($,W);case"/api/exists":return await this.handleExists($,W);default:return this.createErrorResponse({message:"Invalid file endpoint",code:B.UNKNOWN_ERROR},W)}}async handleRead($,W){let J=await this.parseRequestBody($),Q=await this.fileService.readFile(J.path,{encoding:J.encoding});if(Q.success){let X={success:!0,path:J.path,content:Q.data,timestamp:new Date().toISOString(),encoding:Q.metadata?.encoding,isBinary:Q.metadata?.isBinary,mimeType:Q.metadata?.mimeType,size:Q.metadata?.size};return this.createTypedResponse(X,W)}else return this.createErrorResponse(Q.error,W)}async handleReadStream($,W){let J=await this.parseRequestBody($);try{let Q=await this.fileService.readFileStreamOperation(J.path,J.sessionId);return new Response(Q,{headers:{"Content-Type":"text/event-stream","Cache-Control":"no-cache",Connection:"keep-alive",...W.corsHeaders}})}catch(Q){this.logger.error("File streaming failed",Q instanceof Error?Q:void 0,{requestId:W.requestId,path:J.path});let X=new TextEncoder,Y={type:"error",error:Q instanceof Error?Q.message:"Unknown error"},_=new ReadableStream({start(G){G.enqueue(X.encode(`data: ${JSON.stringify(Y)}

`)),G.close()}});return new Response(_,{headers:{"Content-Type":"text/event-stream","Cache-Control":"no-cache",Connection:"keep-alive",...W.corsHeaders}})}}async handleWrite($,W){let J=await this.parseRequestBody($),Q=await this.fileService.writeFile(J.path,J.content,{encoding:J.encoding});if(Q.success){let X={success:!0,path:J.path,timestamp:new Date().toISOString()};return this.createTypedResponse(X,W)}else return this.createErrorResponse(Q.error,W)}async handleDelete($,W){let J=await this.parseRequestBody($),Q=await this.fileService.deleteFile(J.path);if(Q.success){let X={success:!0,path:J.path,timestamp:new Date().toISOString()};return this.createTypedResponse(X,W)}else return this.createErrorResponse(Q.error,W)}async handleRename($,W){let J=await this.parseRequestBody($),Q=await this.fileService.renameFile(J.oldPath,J.newPath);if(Q.success){let X={success:!0,path:J.oldPath,newPath:J.newPath,timestamp:new Date().toISOString()};return this.createTypedResponse(X,W)}else return this.createErrorResponse(Q.error,W)}async handleMove($,W){let J=await this.parseRequestBody($),Q=await this.fileService.moveFile(J.sourcePath,J.destinationPath);if(Q.success){let X={success:!0,path:J.sourcePath,newPath:J.destinationPath,timestamp:new Date().toISOString()};return this.createTypedResponse(X,W)}else return this.createErrorResponse(Q.error,W)}async handleMkdir($,W){let J=await this.parseRequestBody($),Q=await this.fileService.createDirectory(J.path,{recursive:J.recursive});if(Q.success){let X={success:!0,path:J.path,recursive:J.recursive??!1,timestamp:new Date().toISOString()};return this.createTypedResponse(X,W)}else return this.createErrorResponse(Q.error,W)}async handleListFiles($,W){let J=await this.parseRequestBody($),Q=await this.fileService.listFiles(J.path,J.options||{},J.sessionId);if(Q.success){let X={success:!0,path:J.path,files:Q.data,count:Q.data.length,timestamp:new Date().toISOString()};return this.createTypedResponse(X,W)}else return this.createErrorResponse(Q.error,W)}async handleExists($,W){let J=await this.parseRequestBody($),Q=await this.fileService.exists(J.path,J.sessionId);if(Q.success){let X={success:!0,path:J.path,exists:Q.data,timestamp:new Date().toISOString()};return this.createTypedResponse(X,W)}else return this.createErrorResponse(Q.error,W)}}class GW extends Z{gitService;constructor($,W){super(W);this.gitService=$}async handle($,W){switch(new URL($.url).pathname){case"/api/git/checkout":return await this.handleCheckout($,W);default:return this.createErrorResponse({message:"Invalid git endpoint",code:B.UNKNOWN_ERROR},W)}}async handleCheckout($,W){let J=await this.parseRequestBody($),Q=J.sessionId||W.sessionId,X=await this.gitService.cloneRepository(J.repoUrl,{branch:J.branch,targetDir:J.targetDir,sessionId:Q});if(X.success){let Y={success:!0,repoUrl:J.repoUrl,branch:X.data.branch,targetDir:X.data.path,timestamp:new Date().toISOString()};return this.createTypedResponse(Y,W)}else return this.logger.error("Repository clone failed",void 0,{requestId:W.requestId,repoUrl:J.repoUrl,errorCode:X.error.code,errorMessage:X.error.message}),this.createErrorResponse(X.error,W)}}class HW extends Z{interpreterService;constructor($,W){super(W);this.interpreterService=$}async handle($,W){let Q=new URL($.url).pathname;if(Q==="/api/interpreter/health"&&$.method==="GET")return await this.handleHealth($,W);if(Q==="/api/contexts"&&$.method==="POST")return await this.handleCreateContext($,W);else if(Q==="/api/contexts"&&$.method==="GET")return await this.handleListContexts($,W);else if(Q.startsWith("/api/contexts/")){let X=Q.split("/")[3];if($.method==="DELETE")return await this.handleDeleteContext($,W,X)}if(Q==="/api/execute/code"&&$.method==="POST")return await this.handleExecuteCode($,W);return this.createErrorResponse({message:"Invalid interpreter endpoint",code:B.UNKNOWN_ERROR},W)}async handleHealth($,W){let J=await this.interpreterService.getHealthStatus();if(J.success){let Q={success:!0,status:J.data.ready?"healthy":"unhealthy",timestamp:new Date().toISOString()};return this.createTypedResponse(Q,W)}else return this.createErrorResponse(J.error,W)}async handleCreateContext($,W){let J=await this.parseRequestBody($),Q=await this.interpreterService.createContext(J);if(Q.success){let X=Q.data,Y={success:!0,contextId:X.id,language:X.language,cwd:X.cwd,timestamp:new Date().toISOString()};return this.createTypedResponse(Y,W)}else{if(Q.error.code==="INTERPRETER_NOT_READY"){let X=this.enrichServiceError(Q.error);return new Response(JSON.stringify(X),{status:503,headers:{"Content-Type":"application/json","Retry-After":String(Q.error.details?.retryAfter||5),...W.corsHeaders}})}return this.createErrorResponse(Q.error,W)}}async handleListContexts($,W){let J=await this.interpreterService.listContexts();if(J.success){let Q={success:!0,contexts:J.data.map((X)=>({id:X.id,language:X.language,cwd:X.cwd})),timestamp:new Date().toISOString()};return this.createTypedResponse(Q,W)}else return this.createErrorResponse(J.error,W)}async handleDeleteContext($,W,J){let Q=await this.interpreterService.deleteContext(J);if(Q.success){let X={success:!0,contextId:J,timestamp:new Date().toISOString()};return this.createTypedResponse(X,W)}else return this.createErrorResponse(Q.error,W)}async handleExecuteCode($,W){let J=await this.parseRequestBody($);return await this.interpreterService.executeCode(J.context_id,J.code,J.language)}}class BW extends Z{async handle($,W){switch(new URL($.url).pathname){case"/":return await this.handleRoot($,W);case"/api/health":return await this.handleHealth($,W);case"/api/shutdown":return await this.handleShutdown($,W);case"/api/version":return await this.handleVersion($,W);default:return this.createErrorResponse({message:"Invalid endpoint",code:B.UNKNOWN_ERROR},W)}}async handleRoot($,W){return new Response("Hello from Bun server! \uD83D\uDE80",{headers:{"Content-Type":"text/plain; charset=utf-8",...W.corsHeaders}})}async handleHealth($,W){let J={success:!0,status:"healthy",timestamp:new Date().toISOString()};return this.createTypedResponse(J,W)}async handleShutdown($,W){let J={success:!0,message:"Container shutdown initiated",timestamp:new Date().toISOString()};return this.createTypedResponse(J,W)}async handleVersion($,W){let Q={success:!0,version:process.env.SANDBOX_VERSION||"unknown",timestamp:new Date().toISOString()};return this.createTypedResponse(Q,W)}}class NW extends Z{portService;constructor($,W){super(W);this.portService=$}async handle($,W){let Q=new URL($.url).pathname;if(Q==="/api/expose-port")return await this.handleExpose($,W);else if(Q==="/api/exposed-ports")return await this.handleList($,W);else if(Q.startsWith("/api/exposed-ports/")){let X=Q.split("/");if(X.length>=4){let Y=X[3],_=parseInt(Y,10);if(!Number.isNaN(_)&&$.method==="DELETE")return await this.handleUnexpose($,W,_)}}else if(Q.startsWith("/proxy/"))return await this.handleProxy($,W);return this.createErrorResponse({message:"Invalid port endpoint",code:B.UNKNOWN_ERROR},W)}async handleExpose($,W){let J=await this.parseRequestBody($),Q=await this.portService.exposePort(J.port,J.name);if(Q.success){let X=Q.data,Y={success:!0,port:X.port,url:`http://localhost:${X.port}`,timestamp:new Date().toISOString()};return this.createTypedResponse(Y,W)}else return this.createErrorResponse(Q.error,W)}async handleUnexpose($,W,J){let Q=await this.portService.unexposePort(J);if(Q.success){let X={success:!0,port:J,timestamp:new Date().toISOString()};return this.createTypedResponse(X,W)}else return this.createErrorResponse(Q.error,W)}async handleList($,W){let J=await this.portService.getExposedPorts();if(J.success){let X={success:!0,ports:J.data.map((Y)=>({port:Y.port,url:`http://localhost:${Y.port}`,status:Y.status})),timestamp:new Date().toISOString()};return this.createTypedResponse(X,W)}else return this.createErrorResponse(J.error,W)}async handleProxy($,W){try{let Q=new URL($.url).pathname.split("/");if(Q.length<3)return this.createErrorResponse({message:"Invalid proxy URL format",code:B.UNKNOWN_ERROR},W);let X=Q[2],Y=parseInt(X,10);if(Number.isNaN(Y))return this.createErrorResponse({message:"Invalid port number in proxy URL",code:B.UNKNOWN_ERROR},W);return await this.portService.proxyRequest(Y,$)}catch(J){return this.logger.error("Proxy request failed",J instanceof Error?J:void 0,{requestId:W.requestId}),this.createErrorResponse({message:J instanceof Error?J.message:"Proxy request failed",code:B.UNKNOWN_ERROR},W)}}}class jW extends Z{processService;constructor($,W){super(W);this.processService=$}async handle($,W){let Q=new URL($.url).pathname;if(Q==="/api/process/start")return await this.handleStart($,W);else if(Q==="/api/process/list")return await this.handleList($,W);else if(Q==="/api/process/kill-all")return await this.handleKillAll($,W);else if(Q.startsWith("/api/process/")){let X=Q.split("/");if(X.length>=4){let Y=X[3],_=X[4];if(!_&&$.method==="GET")return await this.handleGet($,W,Y);else if(!_&&$.method==="DELETE")return await this.handleKill($,W,Y);else if(_==="logs"&&$.method==="GET")return await this.handleLogs($,W,Y);else if(_==="stream"&&$.method==="GET")return await this.handleStream($,W,Y)}}return this.createErrorResponse({message:"Invalid process endpoint",code:B.UNKNOWN_ERROR},W)}async handleStart($,W){let J=await this.parseRequestBody($),{command:Q,...X}=J,Y=await this.processService.startProcess(Q,X);if(Y.success){let _=Y.data,G={success:!0,processId:_.id,pid:_.pid,command:_.command,timestamp:new Date().toISOString()};return this.createTypedResponse(G,W)}else return this.createErrorResponse(Y.error,W)}async handleList($,W){let Q=new URL($.url).searchParams.get("status"),X={};if(Q)X.status=Q;let Y=await this.processService.listProcesses(X);if(Y.success){let _={success:!0,processes:Y.data.map((G)=>({id:G.id,pid:G.pid,command:G.command,status:G.status,startTime:G.startTime.toISOString(),exitCode:G.exitCode})),timestamp:new Date().toISOString()};return this.createTypedResponse(_,W)}else return this.createErrorResponse(Y.error,W)}async handleGet($,W,J){let Q=await this.processService.getProcess(J);if(Q.success){let X=Q.data,Y={success:!0,process:{id:X.id,pid:X.pid,command:X.command,status:X.status,startTime:X.startTime.toISOString(),endTime:X.endTime?.toISOString(),exitCode:X.exitCode},timestamp:new Date().toISOString()};return this.createTypedResponse(Y,W)}else return this.createErrorResponse(Q.error,W)}async handleKill($,W,J){let Q=await this.processService.killProcess(J);if(Q.success){let X={success:!0,processId:J,timestamp:new Date().toISOString()};return this.createTypedResponse(X,W)}else return this.createErrorResponse(Q.error,W)}async handleKillAll($,W){let J=await this.processService.killAllProcesses();if(J.success){let Q={success:!0,cleanedCount:J.data,timestamp:new Date().toISOString()};return this.createTypedResponse(Q,W)}else return this.createErrorResponse(J.error,W)}async handleLogs($,W,J){let Q=await this.processService.getProcess(J);if(Q.success){let X=Q.data,Y={success:!0,processId:J,stdout:X.stdout,stderr:X.stderr,timestamp:new Date().toISOString()};return this.createTypedResponse(Y,W)}else return this.createErrorResponse(Q.error,W)}async handleStream($,W,J){let Q=await this.processService.streamProcessLogs(J);if(Q.success){let X=await this.processService.getProcess(J);if(!X.success)return this.createErrorResponse(X.error,W);let Y=X.data,_=new ReadableStream({start(G){let H=`data: ${JSON.stringify({type:"process_info",processId:Y.id,command:Y.command,status:Y.status,timestamp:new Date().toISOString()})}

`;if(G.enqueue(new TextEncoder().encode(H)),Y.stdout){let V=`data: ${JSON.stringify({type:"stdout",data:Y.stdout,processId:Y.id,timestamp:new Date().toISOString()})}

`;G.enqueue(new TextEncoder().encode(V))}if(Y.stderr){let V=`data: ${JSON.stringify({type:"stderr",data:Y.stderr,processId:Y.id,timestamp:new Date().toISOString()})}

`;G.enqueue(new TextEncoder().encode(V))}let N=(V,D)=>{let S=`data: ${JSON.stringify({type:V,data:D,processId:Y.id,timestamp:new Date().toISOString()})}

`;G.enqueue(new TextEncoder().encode(S))},j=(V)=>{if(["completed","failed","killed","error"].includes(V)){let D=`data: ${JSON.stringify({type:"exit",processId:Y.id,exitCode:Y.exitCode,data:`Process ${V} with exit code ${Y.exitCode}`,timestamp:new Date().toISOString()})}

`;G.enqueue(new TextEncoder().encode(D)),G.close()}};if(Y.outputListeners.add(N),Y.statusListeners.add(j),["completed","failed","killed","error"].includes(Y.status)){let V=`data: ${JSON.stringify({type:"exit",processId:Y.id,exitCode:Y.exitCode,data:`Process ${Y.status} with exit code ${Y.exitCode}`,timestamp:new Date().toISOString()})}

`;G.enqueue(new TextEncoder().encode(V)),G.close()}return()=>{Y.outputListeners.delete(N),Y.statusListeners.delete(j)}}});return new Response(_,{status:200,headers:{"Content-Type":"text/event-stream","Cache-Control":"no-cache",Connection:"keep-alive",...W.corsHeaders}})}else return this.createErrorResponse(Q.error,W)}}import{randomBytes as A3}from"crypto";class AW extends Z{sessionManager;constructor($,W){super(W);this.sessionManager=$}async handle($,W){switch(new URL($.url).pathname){case"/api/session/create":return await this.handleCreate($,W);case"/api/session/list":return await this.handleList($,W);case"/api/session/delete":return await this.handleDelete($,W);default:return this.createErrorResponse({message:"Invalid session endpoint",code:B.UNKNOWN_ERROR},W)}}async handleCreate($,W){let J,Q,X;try{let _=await $.json();J=_.id||this.generateSessionId(),Q=_.env||{},X=_.cwd||"/workspace"}catch{J=this.generateSessionId(),Q={},X="/workspace"}let Y=await this.sessionManager.createSession({id:J,env:Q,cwd:X});if(Y.success){let _={success:!0,data:Y.data,timestamp:new Date().toISOString()};return this.createTypedResponse(_,W)}else return this.createErrorResponse(Y.error,W)}async handleList($,W){let J=await this.sessionManager.listSessions();if(J.success){let Q={success:!0,data:J.data,timestamp:new Date().toISOString()};return this.createTypedResponse(Q,W)}else return this.createErrorResponse(J.error,W)}async handleDelete($,W){let J;try{if(J=await $.json(),!J.sessionId)return this.createErrorResponse({message:"sessionId is required",code:B.VALIDATION_FAILED},W)}catch{return this.createErrorResponse({message:"Invalid request body",code:B.VALIDATION_FAILED},W)}let Q=J.sessionId,X=await this.sessionManager.deleteSession(Q);if(X.success){let Y={success:!0,sessionId:Q,timestamp:new Date().toISOString()};return this.createTypedResponse(Y,W)}else return this.createErrorResponse(X.error,W)}generateSessionId(){return`session_${Date.now()}_${A3(6).toString("hex")}`}}class OW{async handle($,W,J){if($.method==="OPTIONS")return new Response(null,{status:200,headers:W.corsHeaders});let Q=await J();return new Response(Q.body,{status:Q.status,statusText:Q.statusText,headers:{...Object.fromEntries(Q.headers.entries()),...W.corsHeaders}})}}class VW{logger;constructor($){this.logger=$}async handle($,W,J){let Q=Date.now(),X=$.method,Y=new URL($.url).pathname;this.logger.info("Request started",{requestId:W.requestId,method:X,pathname:Y,sessionId:W.sessionId,timestamp:W.timestamp.toISOString()});try{let _=await J(),G=Date.now()-Q;return this.logger.info("Request completed",{requestId:W.requestId,method:X,pathname:Y,status:_.status,duration:G}),_}catch(_){let G=Date.now()-Q;throw this.logger.error("Request failed",_ instanceof Error?_:Error("Unknown error"),{requestId:W.requestId,method:X,pathname:Y,duration:G}),_}}}class zW{securityService;constructor($){this.securityService=$}validatePath($){let W=this.securityService.validatePath($);return{isValid:W.isValid,errors:W.errors.map((J)=>J.message)}}validatePort($){let W=this.securityService.validatePort($);return{isValid:W.isValid,errors:W.errors.map((J)=>J.message)}}validateGitUrl($){let W=this.securityService.validateGitUrl($);return{isValid:W.isValid,errors:W.errors.map((J)=>J.message)}}validateCommand($){let W=this.securityService.validateCommand($);return{isValid:W.isValid,errors:W.errors.map((J)=>J.message)}}}class a${logger;static RESERVED_PORTS=[3000];constructor($){this.logger=$}validatePath($){let W=[];if(!$||typeof $!=="string")return W.push("Path must be a non-empty string"),{isValid:!1,errors:W.map((X)=>({field:"path",message:X,code:"INVALID_PATH"}))};if($.includes("\x00"))W.push("Path contains null bytes");if($.length>4096)W.push("Path too long (max 4096 characters)");let J=W.length===0,Q=W.map((X)=>({field:"path",message:X,code:"INVALID_PATH"}));if(!J)this.logger.warn("Path validation failed",{path:$,errors:W});if(J)return{isValid:!0,errors:Q,data:$};else return{isValid:!1,errors:Q}}validatePort($){let W=[];if(!Number.isInteger($))W.push("Port must be an integer");else{if($<1||$>65535)W.push("Port must be between 1 and 65535");if(a$.RESERVED_PORTS.includes($))W.push(`Port ${$} is reserved for the sandbox API control plane`)}let J=W.length===0,Q=W.map((X)=>({field:"port",message:X,code:"INVALID_PORT"}));if(!J)this.logger.warn("Port validation failed",{port:$,errors:W});if(J)return{isValid:!0,errors:Q,data:$};else return{isValid:!1,errors:Q}}validateCommand($){let W=[];if(!$||typeof $!=="string")return W.push("Command must be a non-empty string"),{isValid:!1,errors:W.map((Y)=>({field:"command",message:Y,code:"INVALID_COMMAND"}))};let J=$.trim();if(J.length===0)W.push("Command cannot be empty");if(J.length>8192)W.push("Command too long (max 8192 characters)");if(J.includes("\x00"))W.push("Command contains null bytes");let Q=W.length===0,X=W.map((Y)=>({field:"command",message:Y,code:"INVALID_COMMAND"}));if(!Q)this.logger.warn("Command validation failed",{command:J,errors:W});if(Q)return{isValid:!0,errors:X,data:J};else return{isValid:!1,errors:X}}validateGitUrl($){let W=[];if(!$||typeof $!=="string")return W.push("Git URL must be a non-empty string"),{isValid:!1,errors:W.map((Y)=>({field:"gitUrl",message:Y,code:"INVALID_GIT_URL"}))};let J=$.trim();if(J.length===0)W.push("Git URL cannot be empty");if(J.length>2048)W.push("Git URL too long (max 2048 characters)");if(J.includes("\x00"))W.push("Git URL contains null bytes");let Q=W.length===0,X=W.map((Y)=>({field:"gitUrl",message:Y,code:"INVALID_GIT_URL"}));if(!Q)this.logger.warn("Git URL validation failed",{gitUrl:J,errors:W});if(Q)return{isValid:!0,errors:X,data:J};else return{isValid:!1,errors:X}}generateSecureSessionId(){let $=Date.now(),W=new Uint8Array(16);crypto.getRandomValues(W);let J=Array.from(W).map((Q)=>Q.toString(16).padStart(2,"0")).join("");return`session_${$}_${J}`}logSecurityEvent($,W){this.logger.warn(`SECURITY_EVENT: ${$}`,{timestamp:new Date().toISOString(),event:$,...W})}}class KW{parseStatOutput($){let W=$.trim().split(":");if(W.length<4)throw Error(`Invalid stat output format: expected 4 parts, got ${W.length}`);let[J,Q,X,Y]=W,_=J.toLowerCase();return{isFile:_.includes("regular file"),isDirectory:_.includes("directory"),size:parseInt(Q,10),modified:new Date(parseInt(X,10)*1000),created:new Date(parseInt(Y,10)*1000)}}buildMkdirArgs($,W={}){let J=["mkdir"];if(W.recursive)J.push("-p");return J.push($),J}buildStatArgs($){return{command:"stat",args:["-c","%F:%s:%Y:%W",$],format:"type:size:modified:created"}}determineErrorCode($,W){let Q=(typeof W==="string"?W:W.message).toLowerCase();if(Q.includes("not found")||Q.includes("enoent"))return"FILE_NOT_FOUND";if(Q.includes("permission")||Q.includes("eacces"))return"PERMISSION_DENIED";if(Q.includes("exists")||Q.includes("eexist"))return"FILE_EXISTS";if(Q.includes("disk full")||Q.includes("enospc"))return"DISK_FULL";if(Q.includes("directory not empty")||Q.includes("enotempty"))return"DIR_NOT_EMPTY";switch($){case"read":return"FILE_READ_ERROR";case"write":return"FILE_WRITE_ERROR";case"delete":return"FILE_DELETE_ERROR";case"rename":return"RENAME_ERROR";case"move":return"MOVE_ERROR";case"mkdir":return"MKDIR_ERROR";case"stat":return"STAT_ERROR";case"exists":return"EXISTS_ERROR";default:return"FILE_OPERATION_ERROR"}}validateStats($){let W=[];if($.size<0)W.push("File size cannot be negative");if($.size>Number.MAX_SAFE_INTEGER)W.push("File size exceeds maximum safe integer");if($.modified<new Date("1970-01-01"))W.push("Modified date cannot be before Unix epoch");if($.created<new Date("1970-01-01"))W.push("Created date cannot be before Unix epoch");if($.modified<$.created);return{valid:W.length===0,errors:W}}planOperation($,...W){switch($){case"read":return{operation:"read",paths:[W[0]],requiresCheck:!0};case"write":return{operation:"write",paths:[W[0]],requiresCheck:!1};case"delete":return{operation:"delete",paths:[W[0]],requiresCheck:!0,command:{executable:"rm",args:[W[0]]}};case"rename":return{operation:"rename",paths:[W[0],W[1]],requiresCheck:!0,command:{executable:"mv",args:[W[0],W[1]]}};case"move":return{operation:"move",paths:[W[0],W[1]],requiresCheck:!0};case"mkdir":return{operation:"mkdir",paths:[W[0]],requiresCheck:!1};case"stat":return{operation:"stat",paths:[W[0]],requiresCheck:!0};default:throw Error(`Unknown operation: ${$}`)}}shouldUseMoveCommand($,W){let J=$.split("/")[1],Q=W.split("/")[1];return J===Q}formatFileSize($){if($===0)return"0 B";let W=["B","KB","MB","GB","TB"],J=1024,Q=Math.floor(Math.log($)/Math.log(J));return`${parseFloat(($/J**Q).toFixed(2))} ${W[Q]}`}createErrorMessage($,W,J){return`Failed to ${{read:"read",write:"write",delete:"delete",rename:"rename",move:"move",mkdir:"create directory",stat:"get stats for",exists:"check existence of"}[$]||"operate on"} ${W}: ${J}`}}class UW{security;logger;sessionManager;manager;constructor($,W,J){this.security=$;this.logger=W;this.sessionManager=J;this.manager=new KW}async read($,W={},J="default"){try{let Q=this.security.validatePath($);if(!Q.isValid)return{success:!1,error:{message:`Invalid path format for '${$}': ${Q.errors.join(", ")}`,code:B.VALIDATION_FAILED,details:{validationErrors:Q.errors.map((w)=>({field:"path",message:w,code:"INVALID_PATH"}))}}};let X=await this.exists($,J);if(!X.success)return{success:!1,error:X.error};if(!X.data)return{success:!1,error:{message:`File not found: ${$}`,code:B.FILE_NOT_FOUND,details:{path:$,operation:f.FILE_READ}}};let Y=I($),_=`stat -c '%s' ${Y} 2>/dev/null`,G=await this.sessionManager.executeInSession(J,_);if(!G.success)return{success:!1,error:{message:`Failed to get file size for '${$}'`,code:B.FILESYSTEM_ERROR,details:{path:$,operation:f.FILE_READ,stderr:"Command execution failed"}}};if(G.data.exitCode!==0)return{success:!1,error:{message:`Failed to get file size for '${$}'`,code:B.FILESYSTEM_ERROR,details:{path:$,operation:f.FILE_READ,stderr:G.data.stderr}}};let H=parseInt(G.data.stdout.trim(),10);if(Number.isNaN(H))return{success:!1,error:{message:`Failed to parse file size for '${$}': invalid stat output`,code:B.FILESYSTEM_ERROR,details:{path:$,operation:f.FILE_READ,stderr:`Unexpected stat output: ${G.data.stdout}`}}};let N=`file --mime-type -b ${Y}`,j=await this.sessionManager.executeInSession(J,N);if(!j.success)return{success:!1,error:{message:`Failed to detect MIME type for '${$}'`,code:B.FILESYSTEM_ERROR,details:{path:$,operation:f.FILE_READ,stderr:"Command execution failed"}}};if(j.data.exitCode!==0)return{success:!1,error:{message:`Failed to detect MIME type for '${$}'`,code:B.FILESYSTEM_ERROR,details:{path:$,operation:f.FILE_READ,stderr:j.data.stderr}}};let V=j.data.stdout.trim(),D=this.isBinaryMimeType(V),S;if(W.encoding==="base64")S="base64";else if(W.encoding==="utf-8"||W.encoding==="utf8")S="utf-8";else S=D?"base64":"utf-8";let E;if(S==="base64"){let w=`base64 -w 0 < ${Y}`,F=await this.sessionManager.executeInSession(J,w);if(!F.success)return{success:!1,error:{message:`Failed to read binary file '${$}': Command execution failed`,code:B.FILESYSTEM_ERROR,details:{path:$,operation:f.FILE_READ}}};if(F.data.exitCode!==0)return{success:!1,error:{message:`Failed to read binary file '${$}': ${F.data.stderr}`,code:B.FILESYSTEM_ERROR,details:{path:$,operation:f.FILE_READ,exitCode:F.data.exitCode,stderr:F.data.stderr}}};E=F.data.stdout.trim()}else{let w=`cat ${Y}`,F=await this.sessionManager.executeInSession(J,w);if(!F.success)return{success:!1,error:{message:`Failed to read text file '${$}': Command execution failed`,code:B.FILESYSTEM_ERROR,details:{path:$,operation:f.FILE_READ}}};if(F.data.exitCode!==0)return{success:!1,error:{message:`Failed to read text file '${$}': ${F.data.stderr}`,code:B.FILESYSTEM_ERROR,details:{path:$,operation:f.FILE_READ,exitCode:F.data.exitCode,stderr:F.data.stderr}}};E=F.data.stdout}return{success:!0,data:E,metadata:{encoding:S,isBinary:S==="base64",mimeType:V,size:H}}}catch(Q){let X=Q instanceof Error?Q.message:"Unknown error";return this.logger.error("Failed to read file",Q instanceof Error?Q:void 0,{path:$}),{success:!1,error:{message:`Failed to read file '${$}': ${X}`,code:B.FILESYSTEM_ERROR,details:{path:$,operation:f.FILE_READ,stderr:X}}}}}async write($,W,J={},Q="default"){try{let X=this.security.validatePath($);if(!X.isValid)return{success:!1,error:{message:`Invalid path format for '${$}': ${X.errors.join(", ")}`,code:B.VALIDATION_FAILED,details:{validationErrors:X.errors.map((j)=>({field:"path",message:j,code:"INVALID_PATH"}))}}};let Y=I($),_=J.encoding||"utf-8",G;if(_==="base64"){if(!/^[A-Za-z0-9+/=]*$/.test(W))return{success:!1,error:{message:`Invalid base64 content for '${$}': must contain only A-Z, a-z, 0-9, +, /, =`,code:B.VALIDATION_FAILED,details:{validationErrors:[{field:"content",message:"Invalid base64 characters",code:"INVALID_BASE64"}]}}};G=`printf '%s' '${W}' | base64 -d > ${Y}`}else G=`printf '%s' '${Buffer.from(W,"utf-8").toString("base64")}' | base64 -d > ${Y}`;let H=await this.sessionManager.executeInSession(Q,G);if(!H.success)return H;let N=H.data;if(N.exitCode!==0)return{success:!1,error:{message:`Failed to write file '${$}': ${N.stderr||`exit code ${N.exitCode}`}`,code:B.FILESYSTEM_ERROR,details:{path:$,operation:f.FILE_WRITE,exitCode:N.exitCode,stderr:N.stderr}}};return{success:!0}}catch(X){let Y=X instanceof Error?X.message:"Unknown error";return this.logger.error("Failed to write file",X instanceof Error?X:void 0,{path:$}),{success:!1,error:{message:`Failed to write file '${$}': ${Y}`,code:B.FILESYSTEM_ERROR,details:{path:$,operation:f.FILE_WRITE,stderr:Y}}}}}async delete($,W="default"){try{let J=this.security.validatePath($);if(!J.isValid)return{success:!1,error:{message:`Invalid path format for '${$}': ${J.errors.join(", ")}`,code:B.VALIDATION_FAILED,details:{validationErrors:J.errors.map((N)=>({field:"path",message:N,code:"INVALID_PATH"}))}}};let Q=await this.exists($,W);if(!Q.success)return Q;if(!Q.data)return{success:!1,error:{message:`File not found: ${$}`,code:B.FILE_NOT_FOUND,details:{path:$,operation:f.FILE_DELETE}}};let X=await this.stat($,W);if(X.success&&X.data.isDirectory)return{success:!1,error:{message:`Cannot delete directory with deleteFile() at '${$}'. Use exec('rm -rf <path>') instead.`,code:B.IS_DIRECTORY,details:{path:$,operation:f.FILE_DELETE}}};let _=`rm ${I($)}`,G=await this.sessionManager.executeInSession(W,_);if(!G.success)return G;let H=G.data;if(H.exitCode!==0)return{success:!1,error:{message:`Failed to delete file '${$}': ${H.stderr||`exit code ${H.exitCode}`}`,code:B.FILESYSTEM_ERROR,details:{path:$,operation:f.FILE_DELETE,exitCode:H.exitCode,stderr:H.stderr}}};return{success:!0}}catch(J){let Q=J instanceof Error?J.message:"Unknown error";return this.logger.error("Failed to delete file",J instanceof Error?J:void 0,{path:$}),{success:!1,error:{message:`Failed to delete file '${$}': ${Q}`,code:B.FILESYSTEM_ERROR,details:{path:$,operation:f.FILE_DELETE,stderr:Q}}}}}async rename($,W,J="default"){try{let Q=this.security.validatePath($),X=this.security.validatePath(W);if(!Q.isValid||!X.isValid){let V=[...Q.errors,...X.errors];return{success:!1,error:{message:`Security validation failed: ${V.join(", ")}`,code:"SECURITY_VALIDATION_FAILED",details:{oldPath:$,newPath:W,errors:V}}}}let Y=await this.exists($,J);if(!Y.success)return Y;if(!Y.data)return{success:!1,error:{message:`Source file not found: ${$}`,code:B.FILE_NOT_FOUND,details:{path:$,operation:f.FILE_RENAME}}};let _=I($),G=I(W),H=`mv ${_} ${G}`,N=await this.sessionManager.executeInSession(J,H);if(!N.success)return N;let j=N.data;if(j.exitCode!==0)return{success:!1,error:{message:`Rename operation failed with exit code ${j.exitCode}`,code:B.FILESYSTEM_ERROR,details:{oldPath:$,newPath:W,exitCode:j.exitCode,stderr:j.stderr}}};return{success:!0}}catch(Q){let X=Q instanceof Error?Q.message:"Unknown error";return this.logger.error("Failed to rename file",Q instanceof Error?Q:void 0,{oldPath:$,newPath:W}),{success:!1,error:{message:`Failed to rename file from '${$}' to '${W}': ${X}`,code:B.FILESYSTEM_ERROR,details:{path:$,operation:f.FILE_RENAME,stderr:X}}}}}async move($,W,J="default"){try{let Q=this.security.validatePath($),X=this.security.validatePath(W);if(!Q.isValid||!X.isValid){let V=[...Q.errors,...X.errors];return{success:!1,error:{message:`Security validation failed: ${V.join(", ")}`,code:"SECURITY_VALIDATION_FAILED",details:{sourcePath:$,destinationPath:W,errors:V}}}}let Y=await this.exists($,J);if(!Y.success)return Y;if(!Y.data)return{success:!1,error:{message:`Source file not found: ${$}`,code:B.FILE_NOT_FOUND,details:{path:$,operation:f.FILE_MOVE}}};let _=I($),G=I(W),H=`mv ${_} ${G}`,N=await this.sessionManager.executeInSession(J,H);if(!N.success)return N;let j=N.data;if(j.exitCode!==0)return{success:!1,error:{message:`Move operation failed with exit code ${j.exitCode}`,code:B.FILESYSTEM_ERROR,details:{sourcePath:$,destinationPath:W,exitCode:j.exitCode,stderr:j.stderr}}};return{success:!0}}catch(Q){let X=Q instanceof Error?Q.message:"Unknown error";return this.logger.error("Failed to move file",Q instanceof Error?Q:void 0,{sourcePath:$,destinationPath:W}),{success:!1,error:{message:`Failed to move file from '${$}' to '${W}': ${X}`,code:B.FILESYSTEM_ERROR,details:{path:$,operation:f.FILE_MOVE,stderr:X}}}}}async mkdir($,W={},J="default"){try{let Q=this.security.validatePath($);if(!Q.isValid)return{success:!1,error:{message:`Invalid path format for '${$}': ${Q.errors.join(", ")}`,code:B.VALIDATION_FAILED,details:{validationErrors:Q.errors.map((N)=>({field:"path",message:N,code:"INVALID_PATH"}))}}};let X=this.manager.buildMkdirArgs($,W),Y=I($),_="mkdir";if(W.recursive)_+=" -p";_+=` ${Y}`;let G=await this.sessionManager.executeInSession(J,_);if(!G.success)return G;let H=G.data;if(H.exitCode!==0)return{success:!1,error:{message:`mkdir operation failed with exit code ${H.exitCode}`,code:B.FILESYSTEM_ERROR,details:{path:$,options:W,exitCode:H.exitCode,stderr:H.stderr}}};return{success:!0}}catch(Q){let X=Q instanceof Error?Q.message:"Unknown error";return this.logger.error("Failed to create directory",Q instanceof Error?Q:void 0,{path:$}),{success:!1,error:{message:`Failed to create directory '${$}': ${X}`,code:B.FILESYSTEM_ERROR,details:{path:$,operation:f.DIRECTORY_CREATE,stderr:X}}}}}async exists($,W="default"){try{let J=this.security.validatePath($);if(!J.isValid)return{success:!1,error:{message:`Invalid path format for '${$}': ${J.errors.join(", ")}`,code:B.VALIDATION_FAILED,details:{validationErrors:J.errors.map((G)=>({field:"path",message:G,code:"INVALID_PATH"}))}}};let X=`test -e ${I($)}`,Y=await this.sessionManager.executeInSession(W,X);if(!Y.success)return{success:!0,data:!1};return{success:!0,data:Y.data.exitCode===0}}catch(J){let Q=J instanceof Error?J.message:"Unknown error";return this.logger.warn("Error checking file existence",{path:$,error:Q}),{success:!1,error:{message:`Failed to check file existence for '${$}': ${Q}`,code:B.FILESYSTEM_ERROR,details:{path:$,operation:f.FILE_STAT,stderr:Q}}}}}async stat($,W="default"){try{let J=this.security.validatePath($);if(!J.isValid)return{success:!1,error:{message:`Invalid path format for '${$}': ${J.errors.join(", ")}`,code:B.VALIDATION_FAILED,details:{validationErrors:J.errors.map((V)=>({field:"path",message:V,code:"INVALID_PATH"}))}}};let Q=await this.exists($,W);if(!Q.success)return Q;if(!Q.data)return{success:!1,error:{message:`Path not found: ${$}`,code:B.FILE_NOT_FOUND,details:{path:$,operation:f.FILE_STAT}}};let X=this.manager.buildStatArgs($),Y=I($),_=`stat ${X.args[0]} ${X.args[1]} ${Y}`,G=await this.sessionManager.executeInSession(W,_);if(!G.success)return G;let H=G.data;if(H.exitCode!==0)return{success:!1,error:{message:`stat operation failed with exit code ${H.exitCode}`,code:B.FILESYSTEM_ERROR,details:{path:$,exitCode:H.exitCode,stderr:H.stderr}}};let N=this.manager.parseStatOutput(H.stdout),j=this.manager.validateStats(N);if(!j.valid)this.logger.warn("Stats validation warnings",{path:$,errors:j.errors});return{success:!0,data:N}}catch(J){let Q=J instanceof Error?J.message:"Unknown error";return this.logger.error("Failed to get file stats",J instanceof Error?J:void 0,{path:$}),{success:!1,error:{message:`Failed to get file stats for '${$}': ${Q}`,code:B.FILESYSTEM_ERROR,details:{path:$,operation:f.FILE_STAT,stderr:Q}}}}}async getFileMetadata($,W="default"){try{let J=this.security.validatePath($);if(!J.isValid)return{success:!1,error:{message:`Invalid path format for '${$}': ${J.errors.join(", ")}`,code:B.VALIDATION_FAILED,details:{validationErrors:J.errors.map((D)=>({field:"path",message:D,code:"INVALID_PATH"}))}}};let Q=await this.exists($,W);if(!Q.success)return{success:!1,error:Q.error};if(!Q.data)return{success:!1,error:{message:`File not found: ${$}`,code:B.FILE_NOT_FOUND,details:{path:$,operation:f.FILE_READ}}};let X=I($),Y=`stat -c '%s' ${X} 2>/dev/null`,_=await this.sessionManager.executeInSession(W,Y);if(!_.success)return{success:!1,error:{message:`Failed to get file size for '${$}'`,code:B.FILESYSTEM_ERROR,details:{path:$,operation:f.FILE_READ,stderr:"Command execution failed"}}};if(_.data.exitCode!==0)return{success:!1,error:{message:`Failed to get file size for '${$}'`,code:B.FILESYSTEM_ERROR,details:{path:$,operation:f.FILE_READ,stderr:_.data.stderr}}};let G=parseInt(_.data.stdout.trim(),10);if(Number.isNaN(G))return{success:!1,error:{message:`Failed to parse file size for '${$}': invalid stat output`,code:B.FILESYSTEM_ERROR,details:{path:$,operation:f.FILE_READ,stderr:`Unexpected stat output: ${_.data.stdout}`}}};let H=`file --mime-type -b ${X}`,N=await this.sessionManager.executeInSession(W,H);if(!N.success)return{success:!1,error:{message:`Failed to detect MIME type for '${$}'`,code:B.FILESYSTEM_ERROR,details:{path:$,operation:f.FILE_READ,stderr:"Command execution failed"}}};if(N.data.exitCode!==0)return{success:!1,error:{message:`Failed to detect MIME type for '${$}'`,code:B.FILESYSTEM_ERROR,details:{path:$,operation:f.FILE_READ,stderr:N.data.stderr}}};let j=N.data.stdout.trim(),V=this.isBinaryMimeType(j);return{success:!0,data:{mimeType:j,size:G,isBinary:V,encoding:V?"base64":"utf-8"}}}catch(J){let Q=J instanceof Error?J.message:"Unknown error";return this.logger.error("Failed to get file metadata",J instanceof Error?J:void 0,{path:$}),{success:!1,error:{message:`Failed to get file metadata for '${$}': ${Q}`,code:B.FILESYSTEM_ERROR,details:{path:$,operation:f.FILE_READ,stderr:Q}}}}}async readFile($,W,J){return await this.read($,W,J)}async writeFile($,W,J,Q){return await this.write($,W,J,Q)}async deleteFile($,W){return await this.delete($,W)}async renameFile($,W,J){return await this.rename($,W,J)}async moveFile($,W,J){return await this.move($,W,J)}async createDirectory($,W,J){return await this.mkdir($,W,J)}async getFileStats($,W){return await this.stat($,W)}async listFiles($,W,J){return await this.list($,W,J)}async list($,W={},J="default"){try{let Q=this.security.validatePath($);if(!Q.isValid)return{success:!1,error:{message:`Invalid path format for '${$}': ${Q.errors.join(", ")}`,code:B.VALIDATION_FAILED,details:{validationErrors:Q.errors.map((S)=>({field:"path",message:S,code:"INVALID_PATH"}))}}};let X=await this.exists($,J);if(!X.success)return{success:!1,error:X.error};if(!X.data)return{success:!1,error:{message:`Directory not found: ${$}`,code:B.FILE_NOT_FOUND,details:{path:$,operation:f.DIRECTORY_LIST}}};let Y=await this.stat($,J);if(Y.success&&!Y.data.isDirectory)return{success:!1,error:{message:`Path is not a directory: ${$}`,code:B.NOT_DIRECTORY,details:{path:$,operation:f.DIRECTORY_LIST}}};let _=I($),G=$.endsWith("/")?$.slice(0,-1):$,H=`find ${_}`;if(!W.recursive)H+=" -maxdepth 1";if(!W.includeHidden)H+=' -not -name ".*"';H+=` -not -path ${_} -printf '%p\\t%y\\t%s\\t%TY-%Tm-%TdT%TH:%TM:%TS\\t%m\\n'`;let N=await this.sessionManager.executeInSession(J,H);if(!N.success)return{success:!1,error:N.error};let j=N.data;if(j.exitCode!==0)return{success:!1,error:{message:`Failed to list files in '${$}': ${j.stderr||`exit code ${j.exitCode}`}`,code:B.FILESYSTEM_ERROR,details:{path:$,operation:f.DIRECTORY_LIST,exitCode:j.exitCode,stderr:j.stderr}}};let V=[],D=j.stdout.trim().split(`
`).filter((S)=>S.trim());for(let S of D){let E=S.split("\t");if(E.length!==5)continue;let[w,F,x,v,P]=E,C;switch(F){case"f":C="file";break;case"d":C="directory";break;case"l":C="symlink";break;default:C="other"}let A=parseInt(x,10),l=parseInt(P,8),Z$=w.startsWith(`${G}/`)?w.substring(G.length+1):w===G?".":w.split("/").pop()||"",e=w.split("/").pop()||"",d$=this.modeToString(l),Y3=this.getPermissions(l);V.push({name:e,absolutePath:w,relativePath:Z$,type:C,size:A,modifiedAt:v,mode:d$,permissions:Y3})}return{success:!0,data:V}}catch(Q){let X=Q instanceof Error?Q.message:"Unknown error";return this.logger.error("Failed to list files",Q instanceof Error?Q:void 0,{path:$}),{success:!1,error:{message:`Failed to list files in '${$}': ${X}`,code:B.FILESYSTEM_ERROR,details:{path:$,operation:f.DIRECTORY_LIST,stderr:X}}}}}modeToString($){let W=["---","--x","-w-","-wx","r--","r-x","rw-","rwx"],J=$>>6&7,Q=$>>3&7,X=$&7;return W[J]+W[Q]+W[X]}getPermissions($){let W=$>>6&7;return{readable:(W&4)!==0,writable:(W&2)!==0,executable:(W&1)!==0}}isBinaryMimeType($){return!$.startsWith("text/")&&!$.includes("json")&&!$.includes("xml")&&!$.includes("javascript")&&!$.includes("x-empty")}async readFileStreamOperation($,W="default"){let J=new TextEncoder,Q=I($);return new ReadableStream({start:async(X)=>{try{let Y=await this.getFileMetadata($,W);if(!Y.success){let D={type:"error",error:Y.error.message};X.enqueue(J.encode(`data: ${JSON.stringify(D)}

`)),X.close();return}let _=Y.data,G={type:"metadata",mimeType:_.mimeType,size:_.size,isBinary:_.isBinary,encoding:_.encoding};X.enqueue(J.encode(`data: ${JSON.stringify(G)}

`));let H=65535,N=0,j=0;while(N<_.size){let D=j,S=1,E;if(_.isBinary)E=`dd if=${Q} bs=${H} skip=${D} count=1 2>/dev/null | base64 -w 0`;else E=`dd if=${Q} bs=${H} skip=${D} count=1 2>/dev/null`;let w=await this.sessionManager.executeInSession(W,E);if(!w.success){let P={type:"error",error:`Failed to read chunk at offset ${N}: Command execution failed`};X.enqueue(J.encode(`data: ${JSON.stringify(P)}

`)),X.close();return}if(w.data.exitCode!==0){let P={type:"error",error:`Failed to read chunk at offset ${N}: ${w.data.stderr}`};X.enqueue(J.encode(`data: ${JSON.stringify(P)}

`)),X.close();return}let F=w.data.stdout;if(F.length===0)break;let x={type:"chunk",data:F};X.enqueue(J.encode(`data: ${JSON.stringify(x)}

`));let v;if(_.isBinary){let P=F.replace(/=/g,"").length;v=Math.floor(P*3/4)}else v=F.length;N+=v,j++}let V={type:"complete",bytesRead:_.size};X.enqueue(J.encode(`data: ${JSON.stringify(V)}

`)),X.close()}catch(Y){let _=Y instanceof Error?Y.message:"Unknown error";this.logger.error("File streaming failed",Y instanceof Error?Y:void 0,{path:$});let G={type:"error",error:_};X.enqueue(J.encode(`data: ${JSON.stringify(G)}

`)),X.close()}}})}}class DW{extractRepoName($){try{let J=new URL($).pathname.split("/");return J[J.length-1].replace(/\.git$/,"")}catch{let W=$.match(/\/([^/]+?)(\.git)?$/);if(W?.[1])return W[1];return"repository"}}generateTargetDirectory($){return`/workspace/${this.extractRepoName($)}`}buildCloneArgs($,W,J={}){let Q=["git","clone"];if(J.branch)Q.push("--branch",J.branch);return Q.push($,W),Q}buildCheckoutArgs($){return["git","checkout",$]}buildGetCurrentBranchArgs(){return["git","branch","--show-current"]}buildListBranchesArgs(){return["git","branch","-a"]}parseBranchList($){return $.split(`
`).map((J)=>J.trim()).filter((J)=>J.length>0).map((J)=>J.replace(/^\*\s*/,"")).map((J)=>J.replace(/^remotes\/origin\//,"")).filter((J,Q,X)=>X.indexOf(J)===Q).filter((J)=>J!=="HEAD")}validateBranchName($){if(!$||$.trim().length===0)return{isValid:!1,error:"Branch name cannot be empty"};return{isValid:!0}}determineErrorCode($,W,J){let X=(typeof W==="string"?W:W.message).toLowerCase();if(J===128){if(X.includes("not a git repository"))return"NOT_A_GIT_REPO";if(X.includes("repository not found"))return"REPO_NOT_FOUND";return"GIT_COMMAND_ERROR"}if(X.includes("permission denied")||X.includes("access denied"))return"GIT_PERMISSION_DENIED";if(X.includes("not found")||X.includes("does not exist"))return"GIT_NOT_FOUND";if(X.includes("already exists"))return"GIT_ALREADY_EXISTS";if(X.includes("did not match")||X.includes("pathspec"))return"GIT_INVALID_REF";if(X.includes("authentication")||X.includes("credentials"))return"GIT_AUTH_FAILED";switch($){case"clone":return"GIT_CLONE_FAILED";case"checkout":return"GIT_CHECKOUT_FAILED";case"getCurrentBranch":return"GIT_BRANCH_ERROR";case"listBranches":return"GIT_BRANCH_LIST_ERROR";default:return"GIT_OPERATION_ERROR"}}createErrorMessage($,W,J){let X={clone:"clone repository",checkout:"checkout branch",getCurrentBranch:"get current branch",listBranches:"list branches"}[$]||"perform git operation",Y=Object.entries(W).map(([_,G])=>`${_}=${G}`).join(", ");return`Failed to ${X} (${Y}): ${J}`}isSshUrl($){return $.startsWith("git@")||$.includes(":")&&!$.startsWith("http")}isHttpsUrl($){return $.startsWith("https://")||$.startsWith("http://")}}class MW{security;logger;sessionManager;manager;constructor($,W,J){this.security=$;this.logger=W;this.sessionManager=J;this.manager=new DW}buildCommand($){return $.map((W)=>I(W)).join(" ")}returnError($){return{success:!1,error:X$($)}}returnSuccess($){return{success:!0,data:$}}async cloneRepository($,W={}){try{let J=this.security.validateGitUrl($);if(!J.isValid)return this.returnError({message:`Invalid Git URL '${$}': ${J.errors.join(", ")}`,code:B.INVALID_GIT_URL,details:{validationErrors:J.errors.map((w)=>({field:"repoUrl",message:w,code:"INVALID_GIT_URL"}))}});let Q=W.targetDir||this.manager.generateTargetDirectory($),X=this.security.validatePath(Q);if(!X.isValid)return this.returnError({message:`Invalid target directory '${Q}': ${X.errors.join(", ")}`,code:B.VALIDATION_FAILED,details:{validationErrors:X.errors.map((w)=>({field:"targetDirectory",message:w,code:"INVALID_PATH"}))}});let Y=this.manager.buildCloneArgs($,Q,W),_=this.buildCommand(Y),G=W.sessionId||"default",H=await this.sessionManager.executeInSession(G,_);if(!H.success)return H;let N=H.data;if(N.exitCode!==0){this.logger.error("Git clone failed",void 0,{repoUrl:$,targetDirectory:Q,exitCode:N.exitCode,stderr:N.stderr});let w=this.manager.determineErrorCode("clone",N.stderr||"Unknown error",N.exitCode);return this.returnError({message:`Failed to clone repository '${$}': ${N.stderr||`exit code ${N.exitCode}`}`,code:w,details:{repository:$,targetDir:Q,exitCode:N.exitCode,stderr:N.stderr}})}let j=this.manager.buildGetCurrentBranchArgs(),V=this.buildCommand(j),D=await this.sessionManager.executeInSession(G,V,Q);if(!D.success){let w=W.branch||"unknown";return{success:!0,data:{path:Q,branch:w}}}let S=D.data,E;if(S.exitCode===0&&S.stdout.trim())E=S.stdout.trim();else E=W.branch||"unknown";return this.returnSuccess({path:Q,branch:E})}catch(J){let Q=J instanceof Error?J.message:"Unknown error";return this.logger.error("Failed to clone repository",J instanceof Error?J:void 0,{repoUrl:$,options:W}),this.returnError({message:`Failed to clone repository '${$}': ${Q}`,code:B.GIT_CLONE_FAILED,details:{repository:$,targetDir:W.targetDir,stderr:Q}})}}async checkoutBranch($,W,J="default"){try{let Q=this.security.validatePath($);if(!Q.isValid)return this.returnError({message:`Invalid repository path '${$}': ${Q.errors.join(", ")}`,code:B.VALIDATION_FAILED,details:{validationErrors:Q.errors.map((N)=>({field:"repoPath",message:N,code:"INVALID_PATH"}))}});let X=this.manager.validateBranchName(W);if(!X.isValid)return this.returnError({message:`Invalid branch name '${W}': ${X.error||"Invalid format"}`,code:B.VALIDATION_FAILED,details:{validationErrors:[{field:"branch",message:X.error||"Invalid branch name format",code:"INVALID_BRANCH"}]}});let Y=this.manager.buildCheckoutArgs(W),_=this.buildCommand(Y),G=await this.sessionManager.executeInSession(J,_,$);if(!G.success)return G;let H=G.data;if(H.exitCode!==0){this.logger.error("Git checkout failed",void 0,{repoPath:$,branch:W,exitCode:H.exitCode,stderr:H.stderr});let N=this.manager.determineErrorCode("checkout",H.stderr||"Unknown error",H.exitCode);return this.returnError({message:`Failed to checkout branch '${W}' in '${$}': ${H.stderr||`exit code ${H.exitCode}`}`,code:N,details:{branch:W,targetDir:$,exitCode:H.exitCode,stderr:H.stderr}})}return{success:!0}}catch(Q){let X=Q instanceof Error?Q.message:"Unknown error";return this.logger.error("Failed to checkout branch",Q instanceof Error?Q:void 0,{repoPath:$,branch:W}),this.returnError({message:`Failed to checkout branch '${W}' in '${$}': ${X}`,code:B.GIT_CHECKOUT_FAILED,details:{branch:W,targetDir:$,stderr:X}})}}async getCurrentBranch($,W="default"){try{let J=this.security.validatePath($);if(!J.isValid)return this.returnError({message:`Invalid repository path '${$}': ${J.errors.join(", ")}`,code:B.VALIDATION_FAILED,details:{validationErrors:J.errors.map((H)=>({field:"repoPath",message:H,code:"INVALID_PATH"}))}});let Q=this.manager.buildGetCurrentBranchArgs(),X=this.buildCommand(Q),Y=await this.sessionManager.executeInSession(W,X,$);if(!Y.success)return Y;let _=Y.data;if(_.exitCode!==0){let H=this.manager.determineErrorCode("getCurrentBranch",_.stderr||"Unknown error",_.exitCode);return this.returnError({message:`Failed to get current branch in '${$}': ${_.stderr||`exit code ${_.exitCode}`}`,code:H,details:{targetDir:$,exitCode:_.exitCode,stderr:_.stderr}})}let G=_.stdout.trim();return this.returnSuccess(G)}catch(J){let Q=J instanceof Error?J.message:"Unknown error";return this.logger.error("Failed to get current branch",J instanceof Error?J:void 0,{repoPath:$}),this.returnError({message:`Failed to get current branch in '${$}': ${Q}`,code:B.GIT_OPERATION_FAILED,details:{targetDir:$,stderr:Q}})}}async listBranches($,W="default"){try{let J=this.security.validatePath($);if(!J.isValid)return this.returnError({message:`Invalid repository path '${$}': ${J.errors.join(", ")}`,code:B.VALIDATION_FAILED,details:{validationErrors:J.errors.map((H)=>({field:"repoPath",message:H,code:"INVALID_PATH"}))}});let Q=this.manager.buildListBranchesArgs(),X=this.buildCommand(Q),Y=await this.sessionManager.executeInSession(W,X,$);if(!Y.success)return Y;let _=Y.data;if(_.exitCode!==0){let H=this.manager.determineErrorCode("listBranches",_.stderr||"Unknown error",_.exitCode);return this.returnError({message:`Failed to list branches in '${$}': ${_.stderr||`exit code ${_.exitCode}`}`,code:H,details:{targetDir:$,exitCode:_.exitCode,stderr:_.stderr}})}let G=this.manager.parseBranchList(_.stdout);return this.returnSuccess(G)}catch(J){let Q=J instanceof Error?J.message:"Unknown error";return this.logger.error("Failed to list branches",J instanceof Error?J:void 0,{repoPath:$}),this.returnError({message:`Failed to list branches in '${$}': ${Q}`,code:B.GIT_OPERATION_FAILED,details:{targetDir:$,stderr:Q}})}}}import{randomUUID as R3}from"crypto";import{spawn as S3,spawnSync as w3}from"child_process";import{randomUUID as o$}from"crypto";var F2=Error("timeout while waiting for mutex to become available"),f2=Error("mutex already locked"),O3=Error("request for lock canceled"),V3=function($,W,J,Q){function X(Y){return Y instanceof J?Y:new J(function(_){_(Y)})}return new(J||(J=Promise))(function(Y,_){function G(j){try{N(Q.next(j))}catch(V){_(V)}}function H(j){try{N(Q.throw(j))}catch(V){_(V)}}function N(j){j.done?Y(j.value):X(j.value).then(G,H)}N((Q=Q.apply($,W||[])).next())})};class yW{constructor($,W=O3){this._value=$,this._cancelError=W,this._queue=[],this._weightedWaiters=[]}acquire($=1,W=0){if($<=0)throw Error(`invalid weight ${$}: must be positive`);return new Promise((J,Q)=>{let X={resolve:J,reject:Q,weight:$,priority:W},Y=gW(this._queue,(_)=>W<=_.priority);if(Y===-1&&$<=this._value)this._dispatchItem(X);else this._queue.splice(Y+1,0,X)})}runExclusive($){return V3(this,arguments,void 0,function*(W,J=1,Q=0){let[X,Y]=yield this.acquire(J,Q);try{return yield W(X)}finally{Y()}})}waitForUnlock($=1,W=0){if($<=0)throw Error(`invalid weight ${$}: must be positive`);if(this._couldLockImmediately($,W))return Promise.resolve();else return new Promise((J)=>{if(!this._weightedWaiters[$-1])this._weightedWaiters[$-1]=[];z3(this._weightedWaiters[$-1],{resolve:J,priority:W})})}isLocked(){return this._value<=0}getValue(){return this._value}setValue($){this._value=$,this._dispatchQueue()}release($=1){if($<=0)throw Error(`invalid weight ${$}: must be positive`);this._value+=$,this._dispatchQueue()}cancel(){this._queue.forEach(($)=>$.reject(this._cancelError)),this._queue=[]}_dispatchQueue(){this._drainUnlockWaiters();while(this._queue.length>0&&this._queue[0].weight<=this._value)this._dispatchItem(this._queue.shift()),this._drainUnlockWaiters()}_dispatchItem($){let W=this._value;this._value-=$.weight,$.resolve([W,this._newReleaser($.weight)])}_newReleaser($){let W=!1;return()=>{if(W)return;W=!0,this.release($)}}_drainUnlockWaiters(){if(this._queue.length===0)for(let $=this._value;$>0;$--){let W=this._weightedWaiters[$-1];if(!W)continue;W.forEach((J)=>J.resolve()),this._weightedWaiters[$-1]=[]}else{let $=this._queue[0].priority;for(let W=this._value;W>0;W--){let J=this._weightedWaiters[W-1];if(!J)continue;let Q=J.findIndex((X)=>X.priority<=$);(Q===-1?J:J.splice(0,Q)).forEach((X)=>X.resolve())}}}_couldLockImmediately($,W){return(this._queue.length===0||this._queue[0].priority<W)&&$<=this._value}}function z3($,W){let J=gW($,(Q)=>W.priority<=Q.priority);$.splice(J+1,0,W)}function gW($,W){for(let J=$.length-1;J>=0;J--)if(W($[J]))return J;return-1}var K3=function($,W,J,Q){function X(Y){return Y instanceof J?Y:new J(function(_){_(Y)})}return new(J||(J=Promise))(function(Y,_){function G(j){try{N(Q.next(j))}catch(V){_(V)}}function H(j){try{N(Q.throw(j))}catch(V){_(V)}}function N(j){j.done?Y(j.value):X(j.value).then(G,H)}N((Q=Q.apply($,W||[])).next())})};class s${constructor($){this._semaphore=new yW(1,$)}acquire(){return K3(this,arguments,void 0,function*($=0){let[,W]=yield this._semaphore.acquire(1,$);return W})}runExclusive($,W=0){return this._semaphore.runExclusive(()=>$(),1,W)}isLocked(){return this._semaphore.isLocked()}waitForUnlock($=0){return this._semaphore.waitForUnlock(1,$)}release(){if(this._semaphore.isLocked())this._semaphore.release()}cancel(){return this._semaphore.cancel()}}var U3=parseInt(process.env.INTERPRETER_SPAWN_TIMEOUT_MS||"60000",10),D3=(()=>{let $=parseInt(process.env.INTERPRETER_EXECUTION_TIMEOUT_MS||"0",10);return $===0?void 0:$})(),M3=(()=>{let $=parseInt(process.env.COMMAND_TIMEOUT_MS||"0",10);return $===0?void 0:$})();var $$={INTERPRETER_SPAWN_TIMEOUT_MS:U3,INTERPRETER_EXECUTION_TIMEOUT_MS:D3,COMMAND_TIMEOUT_MS:M3,STREAM_CHUNK_DELAY_MS:100,DEFAULT_CWD:"/workspace"};var hW=(()=>{try{return w3("python3",["--version"],{timeout:5000}).status===0}catch{return!1}})(),L3={python:{executor:"python",minSize:3,maxProcesses:void 0,idleTimeout:300000},javascript:{executor:"javascript",minSize:3,maxProcesses:void 0,idleTimeout:300000},typescript:{executor:"typescript",minSize:3,maxProcesses:void 0,idleTimeout:300000}};class mW{pools=new Map;poolConfigs=new Map;cleanupInterval;logger;contextExecutors=new Map;availableExecutors=new Map;poolLocks=new Map;executorLocks=new Map;constructor($={},W){this.logger=W??N$({component:"executor"});let J=Object.entries(L3);for(let[X,Y]of J){let _=$[X]||{},G=process.env[`${X.toUpperCase()}_POOL_MIN_SIZE`],H=process.env[`${X.toUpperCase()}_POOL_MAX_SIZE`],N={...Y,..._,minSize:G?parseInt(G,10):_.minSize||Y.minSize,maxProcesses:H?parseInt(H,10):_.maxProcesses!==void 0?_.maxProcesses:Y.maxProcesses};this.poolConfigs.set(X,N),this.pools.set(X,[]),this.availableExecutors.set(X,[]),this.poolLocks.set(X,new s$)}let Q=this.poolConfigs.get("python");if(Q)this.cleanupInterval=setInterval(()=>{this.cleanupIdleProcesses()},Q.idleTimeout/2);this.startPreWarming().catch((X)=>{this.logger.debug("Pre-warming failed",{error:X instanceof Error?X.message:String(X)})})}getExecutorLock($){let W=this.executorLocks.get($);if(!W)throw Error(`No mutex found for executor ${$}`);return W}async borrowExecutor($){return await this.poolLocks.get($).runExclusive(async()=>{let J=this.availableExecutors.get($)||[];if(J.length>0)return J.shift();let Q=await this.createProcess($,void 0);return this.pools.get($).push(Q),Q})}async returnExecutor($,W){await this.poolLocks.get($).runExclusive(async()=>{let Q=this.availableExecutors.get($)||[];Q.push(W),this.availableExecutors.set($,Q)})}async execute($,W,J,Q){let X=Date.now(),Y=W;if($==="typescript")try{Y=new Bun.Transpiler({loader:"ts",target:"node"}).transformSync(W)}catch(_){let G=_;return{stdout:"",stderr:`TypeScript compilation error: ${G.message}`,success:!1,executionId:o$(),outputs:[],error:{type:"TranspileError",message:G.message,traceback:G.stack}}}if($==="python"&&!hW)return{stdout:"",stderr:`Python interpreter not available. Use the cloudflare/sandbox:${process.env.SANDBOX_VERSION||"<version>"}-python image variant for Python code execution. See https://developers.cloudflare.com/sandbox/configuration/dockerfile/`,success:!1,executionId:o$(),outputs:[],error:{type:B.PYTHON_NOT_AVAILABLE,message:"Python interpreter not available in this image variant"}};if(J){let _=this.contextExecutors.get(J);if(!_||_.process.killed){if(_)this.contextExecutors.delete(J);throw Error(`Context ${J} not found or executor process terminated`)}if(_.language!==$)throw Error(`Context ${J} was created for ${_.language}, cannot execute ${$} code`);return await this.getExecutorLock(_.id).runExclusive(()=>this.executeInProcess(_,Y,X,Q))}else{let _=await this.borrowExecutor($);try{return await this.getExecutorLock(_.id).runExclusive(()=>this.executeInProcess(_,Y,X,Q))}finally{await this.returnExecutor($,_)}}}async executeInProcess($,W,J,Q){let X=Date.now()-J,Y=o$(),_=Date.now(),G=Q??$$.INTERPRETER_EXECUTION_TIMEOUT_MS,H=await this.executeCode($,W,Y,G),N=Date.now()-_,j=Date.now()-J;return this.logger.debug("Code execution complete",{processAcquireTime:X,execTime:N,totalTime:j,language:$.language}),H}async createProcess($,W){let J=this.poolConfigs.get($),Q=this.pools.get($);if(J.maxProcesses!==void 0&&Q.length>=J.maxProcesses)throw Error(`Maximum ${$} executor limit reached (${J.maxProcesses}). Cannot create new executor.`);let X=Date.now(),Y=o$(),_,G;switch($){case"python":_="python3",G=["-u","/container-server/dist/runtime/executors/python/ipython_executor.py"];break;case"javascript":_="node",G=["/container-server/dist/runtime/executors/javascript/node_executor.js"];break;case"typescript":_="node",G=["/container-server/dist/runtime/executors/javascript/node_executor.js"];break}this.logger.debug("Spawning interpreter process",{language:$,command:_,args:G.join(" ")});let H=S3(_,G,{stdio:["pipe","pipe","pipe"],env:{...process.env,PYTHONUNBUFFERED:"1",NODE_NO_WARNINGS:"1"},cwd:"/workspace"}),N={id:Y,language:$,process:H,sessionId:W,lastUsed:new Date};this.executorLocks.set(Y,new s$);let j=(V,D)=>{if(this.logger.warn("Executor process exited unexpectedly",{language:$,processId:Y,sessionId:W,exitCode:V,signal:D}),W)this.contextExecutors.delete(W);let S=this.pools.get($);if(S){let w=S.indexOf(N);if(w>-1)S.splice(w,1)}let E=this.availableExecutors.get($);if(E){let w=E.indexOf(N);if(w>-1)E.splice(w,1)}this.executorLocks.delete(Y)};return N.exitHandler=j,H.once("exit",j),new Promise((V,D)=>{let S="",E="",w=setTimeout(()=>{H.kill(),this.logger.debug("Interpreter spawn timeout",{language:$,timeoutMs:$$.INTERPRETER_SPAWN_TIMEOUT_MS,stdout:S,stderr:E}),D(Error(`${$} executor failed to start within ${$$.INTERPRETER_SPAWN_TIMEOUT_MS}ms`))},$$.INTERPRETER_SPAWN_TIMEOUT_MS),F=(v)=>{if(S+=v.toString(),this.logger.debug("Interpreter stdout during spawn",{language:$,data:v.toString()}),S.includes('"ready"')){clearTimeout(w),H.stdout?.removeListener("data",F),H.stderr?.removeListener("data",x);let P=Date.now()-X;this.logger.debug("Interpreter process ready",{language:$,processId:Y,readyTime:P}),V(N)}},x=(v)=>{E+=v.toString(),this.logger.debug("Interpreter stderr during spawn",{language:$,data:v.toString()})};H.stdout?.on("data",F),H.stderr?.on("data",x),H.once("error",(v)=>{clearTimeout(w),this.logger.debug("Interpreter spawn error",{language:$,error:v.message}),D(v)}),H.once("exit",(v)=>{if(v!==0)clearTimeout(w),this.logger.debug("Interpreter exited during spawn",{language:$,exitCode:v}),D(Error(`${$} executor exited with code ${v}`))})})}async executeCode($,W,J,Q){let X=JSON.stringify({code:W,executionId:J,timeout:Q});return new Promise((Y,_)=>{let G,H="",N=()=>{if(G)clearTimeout(G);$.process.stdout?.removeListener("data",j)};if(Q!==void 0)G=setTimeout(()=>{N(),_(Error("Execution timeout"))},Q);let j=(V)=>{H+=V.toString();try{let D=JSON.parse(H);N(),Y({stdout:D.stdout||"",stderr:D.stderr||"",success:D.success!==!1,executionId:J,outputs:D.outputs||[],error:D.error||null})}catch(D){}};$.process.stdout?.on("data",j),$.process.stdin?.write(`${X}
`)})}async reserveExecutorForContext($,W){if(W==="python"&&!hW){let Q=process.env.SANDBOX_VERSION||"<version>";throw Error(`Python interpreter not available. Use the cloudflare/sandbox:${Q}-python image variant for Python code execution. See https://developers.cloudflare.com/sandbox/configuration/dockerfile/`)}await this.poolLocks.get(W).runExclusive(async()=>{let Q=this.availableExecutors.get(W)||[],X;if(Q.length>0)X=Q.shift(),this.availableExecutors.set(W,Q),this.logger.debug("Assigned available executor to context",{contextId:$,language:W,executorId:X.id});else X=await this.createProcess(W,$),this.pools.get(W).push(X),this.logger.debug("Created new executor for context",{contextId:$,language:W,executorId:X.id});X.sessionId=$,this.contextExecutors.set($,X)})}async releaseExecutorForContext($,W){let J=this.contextExecutors.get($);if(!J){this.logger.debug("Context already released or never existed",{contextId:$});return}if(this.logger.debug("Releasing executor for context",{contextId:$,language:W,executorId:J.id}),this.contextExecutors.delete($),J.exitHandler)J.process.removeListener("exit",J.exitHandler);this.executorLocks.delete(J.id),J.process.kill();let Q=this.pools.get(W);if(Q){let X=Q.indexOf(J);if(X>-1)Q.splice(X,1)}await this.ensureMinimumPool(W)}isContextExecutorHealthy($){let W=this.contextExecutors.get($);if(!W)return!1;return!W.process.killed&&W.process.exitCode===null}async startPreWarming(){this.logger.debug("Starting pre-warming for all executors");let $=Date.now(),W=Array.from(this.poolConfigs.entries()).map(async([J,Q])=>{if(Q.minSize>0)await this.preWarmExecutor(J,Q)});try{await Promise.all(W);let J=Date.now()-$;this.logger.debug("Pre-warming complete for all executors",{totalTime:J})}catch(J){this.logger.debug("Pre-warming failed",{error:J instanceof Error?J.message:String(J)})}}async preWarmExecutor($,W){let J=Date.now();this.logger.debug("Pre-warming executor",{executor:$,targetCount:W.minSize});for(let Y=0;Y<W.minSize;Y++)try{await this.createUnassignedExecutor($)}catch(_){this.logger.debug("Failed to pre-warm process",{executor:$,processIndex:Y,error:_ instanceof Error?_.message:String(_)})}let Q=Date.now()-J,X=this.availableExecutors.get($)?.length||0;this.logger.debug("Pre-warming executor complete",{executor:$,actualCount:X,targetCount:W.minSize,warmupTime:Q})}cleanupIdleProcesses(){let $=new Date;for(let[W,J]of this.availableExecutors.entries()){let Q=this.poolConfigs.get(W);if(!Q)continue;for(let X=J.length-1;X>=0;X--){let Y=J[X];if($.getTime()-Y.lastUsed.getTime()>Q.idleTimeout&&J.length>Q.minSize){Y.process.kill(),J.splice(X,1),this.executorLocks.delete(Y.id);let G=this.pools.get(W);if(G){let H=G.indexOf(Y);if(H>-1)G.splice(H,1)}this.logger.debug("Cleaned up idle unassigned executor",{language:W,remainingAvailable:J.length})}}}}async ensureMinimumPool($){let W=this.poolConfigs.get($);if(!W)return;let Q=(this.availableExecutors.get($)||[]).length,X=W.minSize-Q;if(X>0){this.logger.debug("Replenishing minimum pool",{language:$,currentAvailable:Q,needed:X,targetMinimum:W.minSize});let Y=[];for(let _=0;_<X;_++)Y.push(this.createUnassignedExecutor($));await Promise.all(Y)}}async createUnassignedExecutor($){let W=await this.createProcess($,void 0),J=this.availableExecutors.get($)||[];J.push(W),this.availableExecutors.set($,J),this.pools.get($).push(W),this.logger.debug("Created unassigned executor",{language:$,executorId:W.id})}getExecutorForContext($){return this.contextExecutors.get($)}getAvailableExecutors($){return this.availableExecutors.get($)||[]}async shutdown(){if(this.cleanupInterval)clearInterval(this.cleanupInterval);let $=Array.from(this.pools.keys());for(let W of $){let J=this.pools.get(W);if(J)for(let Q of J)Q.process.kill()}this.pools.clear(),this.executorLocks.clear()}}var K$=new mW;class xW extends Error{progress;retryAfter;constructor($,W=100,J=1){super($);this.progress=W,this.retryAfter=J,this.name="InterpreterNotReadyError"}}class SW{contexts=new Map;logger;constructor($){this.logger=$}async getHealthStatus(){try{return{success:!0,data:{ready:!0,initializing:!1,progress:100}}}catch($){let W=$ instanceof Error?$.message:"Unknown error";return this.logger.error("Failed to get health status",$ instanceof Error?$:void 0),{success:!1,error:{message:`Failed to get interpreter health status: ${W}`,code:B.INTERNAL_ERROR,details:{originalError:W}}}}}async createContext($){let W=!1,J,Q;try{J=R3(),Q=this.mapLanguage($.language||"python");let X={id:J,language:Q,cwd:$.cwd||"/workspace",createdAt:new Date().toISOString(),lastUsed:new Date().toISOString()};return await K$.reserveExecutorForContext(J,Q),W=!0,this.contexts.set(J,X),{success:!0,data:X}}catch(X){if(W&&J&&Q)try{await K$.releaseExecutorForContext(J,Q)}catch(_){this.logger.error("Failed to release executor after context creation failure",_,{contextId:J,language:Q})}let Y=X instanceof Error?X.message:"Unknown error";if(this.logger.error("Failed to create context",X instanceof Error?X:void 0,{request:$}),X instanceof xW)return{success:!1,error:{message:X.message,code:B.INTERPRETER_NOT_READY,details:{progress:X.progress,retryAfter:X.retryAfter}}};if(Y.includes("Python interpreter not available"))return{success:!1,error:{message:Y,code:B.PYTHON_NOT_AVAILABLE,details:{originalError:Y}}};return{success:!1,error:{message:`Failed to create code context: ${Y}`,code:B.INTERNAL_ERROR,details:{originalError:Y}}}}}async listContexts(){try{return{success:!0,data:Array.from(this.contexts.values())}}catch($){let W=$ instanceof Error?$.message:"Unknown error";return this.logger.error("Failed to list contexts",$ instanceof Error?$:void 0),{success:!1,error:{message:`Failed to list code contexts: ${W}`,code:B.INTERNAL_ERROR,details:{originalError:W}}}}}async deleteContext($){try{let W=this.contexts.get($);if(!W)return{success:!1,error:{message:`Code context '${$}' not found`,code:B.CONTEXT_NOT_FOUND,details:{contextId:$}}};try{await K$.releaseExecutorForContext($,W.language)}catch(J){throw this.logger.error("Failed to release executor for context",J,{contextId:$,language:W.language}),J}finally{this.contexts.delete($)}return{success:!0}}catch(W){let J=W instanceof Error?W.message:"Unknown error";return this.logger.error("Failed to delete context",W instanceof Error?W:void 0,{contextId:$}),{success:!1,error:{message:`Failed to delete code context '${$}': ${J}`,code:B.INTERNAL_ERROR,details:{contextId:$,originalError:J}}}}}async executeCode($,W,J){try{let Q=this.contexts.get($);if(!Q)return new Response(JSON.stringify({error:`Context ${$} not found`}),{status:404,headers:{"Content-Type":"application/json"}});if(Q.lastUsed=new Date().toISOString(),!K$.isContextExecutorHealthy($))return new Response(JSON.stringify({error:"Context executor has terminated. Please delete and recreate the context.",code:B.INTERNAL_ERROR,details:{contextId:$}}),{status:410,headers:{"Content-Type":"application/json"}});let X=this.mapLanguage(J||Q.language),Y=this,_=await K$.execute(X,W,$,void 0),G=new ReadableStream({start(H){let N=new TextEncoder;try{if(_.stdout)H.enqueue(N.encode(Y.formatSSE({type:"stdout",text:_.stdout})));if(_.stderr)H.enqueue(N.encode(Y.formatSSE({type:"stderr",text:_.stderr})));if(_.outputs&&_.outputs.length>0)for(let j of _.outputs){let V=Y.formatOutputData(j);H.enqueue(N.encode(Y.formatSSE({type:"result",...V,metadata:j.metadata||{}})))}if(_.success)H.enqueue(N.encode(Y.formatSSE({type:"execution_complete",execution_count:1})));else if(_.error)H.enqueue(N.encode(Y.formatSSE({type:"error",ename:_.error.type||"ExecutionError",evalue:_.error.message||"Code execution failed",traceback:_.error.traceback?_.error.traceback.split(`
`):[]})));else H.enqueue(N.encode(Y.formatSSE({type:"error",ename:"ExecutionError",evalue:_.stderr||"Code execution failed",traceback:[]})));H.close()}catch(j){Y.logger.error("Code execution failed",j,{contextId:$,language:X}),H.enqueue(N.encode(Y.formatSSE({type:"error",ename:"InternalError",evalue:j instanceof Error?j.message:String(j),traceback:[]}))),H.close()}}});return new Response(G,{headers:{"Content-Type":"text/event-stream","Cache-Control":"no-cache",Connection:"keep-alive"}})}catch(Q){let X=Q instanceof Error?Q.message:"Unknown error";return this.logger.error("Failed to execute code",Q instanceof Error?Q:void 0,{contextId:$}),new Response(JSON.stringify({error:{message:`Failed to execute code in context '${$}': ${X}`,code:B.CODE_EXECUTION_ERROR,details:{contextId:$,evalue:X}}}),{status:500,headers:{"Content-Type":"application/json"}})}}mapLanguage($){switch($.toLowerCase()){case"python":case"python3":return"python";case"javascript":case"js":case"node":return"javascript";case"typescript":case"ts":return"typescript";default:return this.logger.warn("Unknown language, defaulting to python",{requestedLanguage:$}),"python"}}formatOutputData($){let W={};switch($.type){case"image":W.png=$.data;break;case"jpeg":W.jpeg=$.data;break;case"svg":W.svg=$.data;break;case"html":W.html=$.data;break;case"json":W.json=typeof $.data==="string"?JSON.parse($.data):$.data;break;case"latex":W.latex=$.data;break;case"markdown":W.markdown=$.data;break;case"javascript":W.javascript=$.data;break;case"text":W.text=$.data;break;default:W.text=$.data||""}return W}formatSSE($){return`data: ${JSON.stringify($)}

`}}class wW{calculateCleanupThreshold(){return new Date(Date.now()-3600000)}parseProxyPath($,W){let J=new URL($),X=J.pathname.split("/").slice(3).join("/"),Y=`http://localhost:${W}/${X}${J.search}`;return{targetPath:X,targetUrl:Y}}createPortInfo($,W){return{port:$,name:W,exposedAt:new Date,status:"active"}}createInactivePortInfo($){return{...$,status:"inactive"}}determineErrorCode($,W){let Q=(typeof W==="string"?W:W.message).toLowerCase();if(Q.includes("not found")||Q.includes("enoent"))return"PORT_NOT_FOUND";if(Q.includes("already exposed")||Q.includes("conflict"))return"PORT_ALREADY_EXPOSED";if(Q.includes("connection refused")||Q.includes("econnrefused"))return"CONNECTION_REFUSED";if(Q.includes("timeout")||Q.includes("etimedout"))return"CONNECTION_TIMEOUT";switch($){case"expose":return"PORT_EXPOSE_ERROR";case"unexpose":return"PORT_UNEXPOSE_ERROR";case"list":return"PORT_LIST_ERROR";case"get":return"PORT_GET_ERROR";case"proxy":return"PROXY_ERROR";case"update":return"PORT_UPDATE_ERROR";case"cleanup":return"PORT_CLEANUP_ERROR";default:return"PORT_OPERATION_ERROR"}}createErrorMessage($,W,J){return`Failed to ${{expose:"expose",unexpose:"unexpose",list:"list",get:"get info for",proxy:"proxy request to",update:"update",cleanup:"cleanup"}[$]||"operate on"} port ${W}: ${J}`}isValidPortRange($){return $>=1&&$<=65535}formatPortList($){return $.map(({port:W,info:J})=>`${W} (${J.name||"unnamed"}, ${J.status})`).join(", ")}shouldCleanupPort($,W){return $.status==="inactive"&&$.exposedAt<W}}class LW{exposedPorts=new Map;async expose($,W){this.exposedPorts.set($,W)}async unexpose($){this.exposedPorts.delete($)}async get($){return this.exposedPorts.get($)||null}async list(){return Array.from(this.exposedPorts.entries()).map(([$,W])=>({port:$,info:W}))}async cleanup($){let W=0;for(let[J,Q]of Array.from(this.exposedPorts.entries()))if(Q.exposedAt<$&&Q.status==="inactive")this.exposedPorts.delete(J),W++;return W}clear(){this.exposedPorts.clear()}size(){return this.exposedPorts.size}}class RW{store;security;logger;cleanupInterval=null;manager;constructor($,W,J){this.store=$;this.security=W;this.logger=J;this.manager=new wW,this.startCleanupProcess()}async exposePort($,W){try{let J=this.security.validatePort($);if(!J.isValid)return{success:!1,error:{message:`Invalid port number ${$}: ${J.errors.join(", ")}`,code:B.INVALID_PORT_NUMBER,details:{port:$,reason:J.errors.join(", ")}}};let Q=await this.store.get($);if(Q)return{success:!1,error:{message:`Port ${$}${Q.name?` (${Q.name})`:""} is already exposed`,code:B.PORT_ALREADY_EXPOSED,details:{port:$,portName:Q.name}}};let X=this.manager.createPortInfo($,W);return await this.store.expose($,X),{success:!0,data:X}}catch(J){let Q=J instanceof Error?J.message:"Unknown error";return this.logger.error("Failed to expose port",J instanceof Error?J:void 0,{port:$,name:W}),{success:!1,error:{message:`Failed to expose port ${$}${W?` (${W})`:""}: ${Q}`,code:B.PORT_OPERATION_ERROR,details:{port:$,portName:W,stderr:Q}}}}}async unexposePort($){try{if(!await this.store.get($))return{success:!1,error:{message:`Port ${$} is not exposed`,code:B.PORT_NOT_EXPOSED,details:{port:$}}};return await this.store.unexpose($),{success:!0}}catch(W){let J=W instanceof Error?W.message:"Unknown error";return this.logger.error("Failed to unexpose port",W instanceof Error?W:void 0,{port:$}),{success:!1,error:{message:`Failed to unexpose port ${$}: ${J}`,code:B.PORT_OPERATION_ERROR,details:{port:$,stderr:J}}}}}async getExposedPorts(){try{return{success:!0,data:(await this.store.list()).map((J)=>J.info)}}catch($){let W=$ instanceof Error?$.message:"Unknown error";return this.logger.error("Failed to list exposed ports",$ instanceof Error?$:void 0),{success:!1,error:{message:`Failed to list exposed ports: ${W}`,code:B.PORT_OPERATION_ERROR,details:{port:0,stderr:W}}}}}async getPortInfo($){try{let W=await this.store.get($);if(!W)return{success:!1,error:{message:`Port ${$} is not exposed`,code:B.PORT_NOT_EXPOSED,details:{port:$}}};return{success:!0,data:W}}catch(W){let J=W instanceof Error?W.message:"Unknown error";return this.logger.error("Failed to get port info",W instanceof Error?W:void 0,{port:$}),{success:!1,error:{message:`Failed to get info for port ${$}: ${J}`,code:B.PORT_OPERATION_ERROR,details:{port:$,stderr:J}}}}}async proxyRequest($,W){try{if(!await this.store.get($)){let G={error:"Port not found",message:`Port ${$} is not exposed`,port:$};return new Response(JSON.stringify(G),{status:404,headers:{"Content-Type":"application/json"}})}let{targetPath:Q,targetUrl:X}=this.manager.parseProxyPath(W.url,$),Y=new Request(X,{method:W.method,headers:W.headers,body:W.body}),_=await fetch(Y);return new Response(_.body,{status:_.status,statusText:_.statusText,headers:_.headers})}catch(J){let Q=J instanceof Error?J.message:"Unknown error";this.logger.error("Proxy request failed",J instanceof Error?J:void 0,{port:$});let X={error:"Proxy error",message:`Failed to proxy request to port ${$}: ${Q}`,port:$};return new Response(JSON.stringify(X),{status:502,headers:{"Content-Type":"application/json"}})}}async markPortInactive($){try{let W=await this.store.get($);if(!W)return{success:!1,error:{message:`Port ${$} is not exposed`,code:B.PORT_NOT_EXPOSED,details:{port:$}}};let J=this.manager.createInactivePortInfo(W);return await this.store.expose($,J),{success:!0}}catch(W){let J=W instanceof Error?W.message:"Unknown error";return this.logger.error("Failed to mark port as inactive",W instanceof Error?W:void 0,{port:$}),{success:!1,error:{message:`Failed to mark port ${$} as inactive: ${J}`,code:B.PORT_OPERATION_ERROR,details:{port:$,stderr:J}}}}}async cleanupInactivePorts(){try{let $=this.manager.calculateCleanupThreshold();return{success:!0,data:await this.store.cleanup($)}}catch($){let W=$ instanceof Error?$.message:"Unknown error";return this.logger.error("Failed to cleanup ports",$ instanceof Error?$:void 0),{success:!1,error:{message:`Failed to cleanup inactive ports: ${W}`,code:B.PORT_OPERATION_ERROR,details:{port:0,stderr:W}}}}}startCleanupProcess(){this.cleanupInterval=setInterval(async()=>{await this.cleanupInactivePorts()},3600000)}destroy(){if(this.cleanupInterval)clearInterval(this.cleanupInterval),this.cleanupInterval=null}}class qW{validateCommand($){if(!$||$.trim()==="")return{valid:!1,error:"Invalid command: empty command provided",code:"INVALID_COMMAND"};return{valid:!0}}createProcessRecord($,W,J){return{id:J.processId||this.generateProcessId(),command:$,pid:W,status:"running",startTime:new Date,sessionId:J.sessionId,stdout:"",stderr:"",outputListeners:new Set,statusListeners:new Set}}generateProcessId(){return`proc_${Date.now()}_${Math.random().toString(36).substring(2,8)}`}interpretExitCode($){return $===0?"completed":"failed"}}class bW{store;logger;sessionManager;manager;constructor($,W,J){this.store=$;this.logger=W;this.sessionManager=J;this.manager=new qW}async startProcess($,W={}){return this.executeCommandStream($,W)}async executeCommand($,W={}){try{let J=W.sessionId||"default",Q=await this.sessionManager.executeInSession(J,$,W.cwd,W.timeoutMs,W.env);if(!Q.success)return Q;return{success:!0,data:{success:Q.data.exitCode===0,exitCode:Q.data.exitCode,stdout:Q.data.stdout,stderr:Q.data.stderr}}}catch(J){let Q=J instanceof Error?J.message:"Unknown error";return this.logger.error("Failed to execute command",J instanceof Error?J:void 0,{command:$,options:W}),{success:!1,error:{message:`Failed to execute command '${$}': ${Q}`,code:B.COMMAND_EXECUTION_ERROR,details:{command:$,stderr:Q}}}}}async executeCommandStream($,W={}){try{let J=this.manager.validateCommand($);if(!J.valid)return{success:!1,error:{message:J.error||"Invalid command",code:J.code||"INVALID_COMMAND"}};let Q=this.manager.createProcessRecord($,void 0,W),X=W.sessionId||"default",Y={...Q,commandHandle:{sessionId:X,commandId:Q.id}};await this.store.create(Y);let _=await this.sessionManager.executeStreamInSession(X,$,async(G)=>{if(G.type==="stdout"&&G.data)Y.stdout+=G.data,Y.outputListeners.forEach((H)=>{H("stdout",G.data)});else if(G.type==="stderr"&&G.data)Y.stderr+=G.data,Y.outputListeners.forEach((H)=>{H("stderr",G.data)});else if(G.type==="complete"){let H=G.exitCode??0,N=this.manager.interpretExitCode(H),j=new Date;Y.status=N,Y.endTime=j,Y.exitCode=H,Y.statusListeners.forEach((V)=>{V(N)});try{await this.store.update(Y.id,{status:N,endTime:j,exitCode:H})}catch(V){this.logger.error("Failed to update process status",V instanceof Error?V:void 0,{processId:Y.id})}}else if(G.type==="error")Y.status="error",Y.endTime=new Date,Y.statusListeners.forEach((H)=>{H("error")}),this.logger.error("Streaming command error",Error(G.error),{processId:Y.id})},{cwd:W.cwd,env:W.env},Q.id);if(!_.success)return _;return _.data.continueStreaming.catch((G)=>{this.logger.error("Failed to execute streaming command",G,{processId:Y.id,command:$})}),{success:!0,data:Y}}catch(J){let Q=J instanceof Error?J.message:"Unknown error";return this.logger.error("Failed to start streaming command",J instanceof Error?J:void 0,{command:$,options:W}),{success:!1,error:{message:`Failed to start streaming command '${$}': ${Q}`,code:B.STREAM_START_ERROR,details:{command:$,stderr:Q}}}}}async getProcess($){try{let W=await this.store.get($);if(!W)return{success:!1,error:{message:`Process ${$} not found`,code:B.PROCESS_NOT_FOUND,details:{processId:$}}};return{success:!0,data:W}}catch(W){let J=W instanceof Error?W.message:"Unknown error";return this.logger.error("Failed to get process",W instanceof Error?W:void 0,{processId:$}),{success:!1,error:{message:`Failed to get process '${$}': ${J}`,code:B.PROCESS_ERROR,details:{processId:$,stderr:J}}}}}async killProcess($){try{let W=await this.store.get($);if(!W)return{success:!1,error:{message:`Process ${$} not found`,code:B.PROCESS_NOT_FOUND,details:{processId:$}}};if(!W.commandHandle)return{success:!0};let J=await this.sessionManager.killCommand(W.commandHandle.sessionId,W.commandHandle.commandId);if(J.success)await this.store.update($,{status:"killed",endTime:new Date});return J}catch(W){let J=W instanceof Error?W.message:"Unknown error";return this.logger.error("Failed to kill process",W instanceof Error?W:void 0,{processId:$}),{success:!1,error:{message:`Failed to kill process '${$}': ${J}`,code:B.PROCESS_ERROR,details:{processId:$,stderr:J}}}}}async listProcesses($){try{return{success:!0,data:await this.store.list($)}}catch(W){let J=W instanceof Error?W.message:"Unknown error";return this.logger.error("Failed to list processes",W instanceof Error?W:void 0,{filters:$}),{success:!1,error:{message:`Failed to list processes: ${J}`,code:B.PROCESS_ERROR,details:{processId:"list",stderr:J}}}}}async killAllProcesses(){try{let $=await this.store.list({status:"running"}),W=0;for(let J of $)if((await this.killProcess(J.id)).success)W++;return{success:!0,data:W}}catch($){let W=$ instanceof Error?$.message:"Unknown error";return this.logger.error("Failed to kill all processes",$ instanceof Error?$:void 0),{success:!1,error:{message:`Failed to kill all processes: ${W}`,code:B.PROCESS_ERROR,details:{processId:"killAll",stderr:W}}}}}async streamProcessLogs($){try{let W=await this.store.get($);if(!W)return{success:!1,error:{message:`Process ${$} not found`,code:B.PROCESS_NOT_FOUND,details:{processId:$}}};let J=null,Q=null,X=()=>{if(J)W.outputListeners.delete(J),J=null;if(Q)W.statusListeners.delete(Q),Q=null};return{success:!0,data:new ReadableStream({start(_){let G=new TextEncoder;if(W.stdout)_.enqueue(G.encode(W.stdout));if(W.stderr)_.enqueue(G.encode(W.stderr));if(J=(H,N)=>{_.enqueue(G.encode(N))},Q=(H)=>{if(["completed","failed","killed","error"].includes(H))X(),_.close()},W.outputListeners.add(J),W.statusListeners.add(Q),["completed","failed","killed","error"].includes(W.status))X(),_.close()},cancel(){X()}})}}catch(W){let J=W instanceof Error?W.message:"Unknown error";return this.logger.error("Failed to stream process logs",W instanceof Error?W:void 0,{processId:$}),{success:!1,error:{message:`Failed to stream logs for process '${$}': ${J}`,code:B.PROCESS_ERROR,details:{processId:$,stderr:J}}}}}async destroy(){await this.killAllProcesses()}}import{mkdir as q3,unlink as b3}from"fs/promises";class FW{logger;processes=new Map;processDir="/tmp/sandbox-internal/processes";initialized=!1;constructor($){this.logger=$}async ensureInitialized(){if(this.initialized)return;try{await q3(this.processDir,{recursive:!0}),this.initialized=!0}catch($){this.initialized=!0}}async create($){await this.ensureInitialized(),this.processes.set($.id,$)}async get($){await this.ensureInitialized();let W=this.processes.get($);if(W)return W;return await this.readProcessFile($)}async update($,W){await this.ensureInitialized();let J=this.processes.get($);if(!J){let Y=await this.readProcessFile($);if(!Y)throw Error(`Process ${$} not found`);let _={...Y,...W};await this.writeProcessFile($,_);return}let Q={...J,...W};if(this.processes.set($,Q),["completed","failed","killed","error"].includes(Q.status)){try{await this.writeProcessFile($,Q)}catch(Y){this.logger.error("Failed to persist completed process, will be lost on restart",Y instanceof Error?Y:Error(String(Y)),{processId:$})}this.processes.delete($)}}async delete($){await this.ensureInitialized(),this.processes.delete($),await this.deleteProcessFile($)}async list($){await this.ensureInitialized();let W=Array.from(this.processes.values()),J=new Set(W.map((Q)=>Q.id));try{let Q=await Array.fromAsync(new Bun.Glob("*.json").scan({cwd:this.processDir}));for(let X of Q){let Y=X.replace(".json","");if(!J.has(Y)){let _=await this.readProcessFile(Y);if(_)W.push(_)}}}catch(Q){this.logger.error("Failed to scan completed processes from disk",Q instanceof Error?Q:Error(String(Q)))}if($?.status)W=W.filter((Q)=>Q.status===$.status);return W}getProcessFilePath($){return`${this.processDir}/${$}.json`}async writeProcessFile($,W){let J={id:W.id,pid:W.pid,command:W.command,status:W.status,startTime:W.startTime,endTime:W.endTime,exitCode:W.exitCode,stdout:W.stdout,stderr:W.stderr,commandHandle:W.commandHandle},Q=this.getProcessFilePath($);await Bun.write(Q,JSON.stringify(J,null,2))}async readProcessFile($){try{let W=this.getProcessFilePath($),J=Bun.file(W);if(!await J.exists())return null;let Q=await J.text(),X=JSON.parse(Q);return{...X,startTime:new Date(X.startTime),endTime:X.endTime?new Date(X.endTime):void 0,outputListeners:new Set,statusListeners:new Set}}catch(W){return null}}async deleteProcessFile($){try{let W=this.getProcessFilePath($);if(await Bun.file(W).exists())await b3(W)}catch(W){}}}import{randomUUID as lW}from"crypto";import{watch as F3}from"fs";import{mkdir as f3,rm as t$}from"fs/promises";import{tmpdir as k3}from"os";import{basename as E3,dirname as v3,join as s}from"path";var U$="\x01\x01\x01",D$="\x02\x02\x02";class fW{shell=null;shellExitedPromise=null;ready=!1;isDestroying=!1;sessionDir=null;id;options;commandTimeoutMs;logger;runningCommands=new Map;constructor($){this.id=$.id,this.options=$,this.commandTimeoutMs=$.commandTimeoutMs??$$.COMMAND_TIMEOUT_MS,this.logger=$.logger??n$()}async initialize(){this.sessionDir=s(k3(),`session-${this.id}-${Date.now()}`),await f3(this.sessionDir,{recursive:!0}),this.shell=Bun.spawn({cmd:["bash","--norc"],cwd:this.options.cwd||$$.DEFAULT_CWD,env:{...process.env,...this.options.env,LANG:"C.UTF-8",LC_ALL:"C.UTF-8"},stdin:"pipe",stdout:"ignore",stderr:"ignore"}),this.shellExitedPromise=new Promise(($,W)=>{this.shell.exited.then((J)=>{if(this.isDestroying)return;this.logger.error("Shell process exited unexpectedly",Error(`Exit code: ${J??"unknown"}`),{sessionId:this.id,exitCode:J??"unknown"}),this.ready=!1,W(Error(`Shell terminated unexpectedly (exit code: ${J??"unknown"}). Session is dead and cannot execute further commands.`))}).catch((J)=>{if(!this.isDestroying)this.logger.error("Shell exit monitor error",J instanceof Error?J:Error(String(J)),{sessionId:this.id}),this.ready=!1,W(J)})}),this.ready=!0}async exec($,W){this.ensureReady();let J=Date.now(),Q=lW(),X=s(this.sessionDir,`${Q}.log`),Y=s(this.sessionDir,`${Q}.exit`),_=s(this.sessionDir,`${Q}.pid`);this.logger.info("Command execution started",{sessionId:this.id,commandId:Q,operation:"exec",command:$.substring(0,100)});try{this.trackCommand(Q,_,X,Y);let G=this.buildFIFOScript($,Q,X,Y,W?.cwd,!1,W?.env);if(this.shell.stdin&&typeof this.shell.stdin!=="number")this.shell.stdin.write(`${G}
`);else throw Error("Shell stdin is not available");let H=await Promise.race([this.waitForExitCode(Y),this.shellExitedPromise]),{stdout:N,stderr:j}=await this.parseLogFile(X);this.untrackCommand(Q),await this.cleanupCommandFiles(X,Y);let V=Date.now()-J;return this.logger.info("Command execution completed",{sessionId:this.id,commandId:Q,operation:"exec",exitCode:H,duration:V}),{command:$,stdout:N,stderr:j,exitCode:H,duration:V,timestamp:new Date(J).toISOString()}}catch(G){throw this.logger.error("Command execution failed",G instanceof Error?G:Error(String(G)),{sessionId:this.id,commandId:Q,operation:"exec"}),this.untrackCommand(Q),await this.cleanupCommandFiles(X,Y),G}}async*execStream($,W){this.ensureReady();let J=Date.now(),Q=W?.commandId||lW(),X=s(this.sessionDir,`${Q}.log`),Y=s(this.sessionDir,`${Q}.exit`),_=s(this.sessionDir,`${Q}.pid`);this.logger.info("Streaming command execution started",{sessionId:this.id,commandId:Q,operation:"execStream",command:$.substring(0,100)});try{this.trackCommand(Q,_,X,Y);let G=this.buildFIFOScript($,Q,X,Y,W?.cwd,!0,W?.env);if(this.shell.stdin&&typeof this.shell.stdin!=="number")this.shell.stdin.write(`${G}
`);else throw Error("Shell stdin is not available");yield{type:"start",timestamp:new Date().toISOString(),command:$};let H=0,N="";while(!0){if(!this.isReady())await this.shellExitedPromise.catch((w)=>{throw w});let S=Bun.file(Y);if(await S.exists()){N=(await S.text()).trim();break}let E=Bun.file(X);if(await E.exists()){let w=await E.text(),F=w.slice(H);if(H=w.length,F){let x=F.split(`
`);for(let v of x){if(!v)continue;if(v.startsWith(U$))yield{type:"stdout",data:`${v.slice(U$.length)}
`,timestamp:new Date().toISOString()};else if(v.startsWith(D$))yield{type:"stderr",data:`${v.slice(D$.length)}
`,timestamp:new Date().toISOString()}}}}await Bun.sleep($$.STREAM_CHUNK_DELAY_MS)}let j=Bun.file(X);if(await j.exists()){let E=(await j.text()).slice(H);if(E){let w=E.split(`
`);for(let F of w){if(!F)continue;if(F.startsWith(U$))yield{type:"stdout",data:`${F.slice(U$.length)}
`,timestamp:new Date().toISOString()};else if(F.startsWith(D$))yield{type:"stderr",data:`${F.slice(D$.length)}
`,timestamp:new Date().toISOString()}}}}let V=parseInt(N,10);if(Number.isNaN(V))throw Error(`Invalid exit code in file: "${N}"`);let D=Date.now()-J;this.logger.info("Streaming command execution completed",{sessionId:this.id,commandId:Q,operation:"execStream",exitCode:V,duration:D}),yield{type:"complete",exitCode:V,timestamp:new Date().toISOString(),result:{stdout:"",stderr:"",exitCode:V,success:V===0,command:$,duration:D,timestamp:new Date(J).toISOString()}},this.untrackCommand(Q),await this.cleanupCommandFiles(X,Y)}catch(G){this.logger.error("Streaming command execution failed",G instanceof Error?G:Error(String(G)),{sessionId:this.id,commandId:Q,operation:"execStream"}),this.untrackCommand(Q),await this.cleanupCommandFiles(X,Y),yield{type:"error",timestamp:new Date().toISOString(),error:G instanceof Error?G.message:String(G)}}}isReady(){return this.ready&&this.shell!==null&&!this.shell.killed}async killCommand($){let W=this.runningCommands.get($);if(!W)return!1;try{let J=Bun.file(W.pidFile);if(await J.exists()){let X=await J.text(),Y=parseInt(X.trim(),10);if(!Number.isNaN(Y))return process.kill(Y,"SIGTERM"),this.runningCommands.delete($),!0}return this.runningCommands.delete($),!1}catch(J){return this.runningCommands.delete($),!1}}getRunningCommandIds(){return Array.from(this.runningCommands.keys())}async destroy(){this.isDestroying=!0;let $=Array.from(this.runningCommands.keys());if(await Promise.all($.map((W)=>this.killCommand(W))),this.shell&&!this.shell.killed){if(this.shell.stdin&&typeof this.shell.stdin!=="number")try{this.shell.stdin.end()}catch{}this.shell.kill();try{await Promise.race([this.shell.exited,new Promise((W,J)=>setTimeout(()=>J(Error("Timeout")),1000))])}catch{this.shell.kill("SIGKILL"),await this.shell.exited.catch(()=>{})}}if(this.sessionDir)await t$(this.sessionDir,{recursive:!0,force:!0}).catch(()=>{});this.ready=!1,this.shell=null,this.shellExitedPromise=null,this.sessionDir=null}buildFIFOScript($,W,J,Q,X,Y=!1,_){let G=s(this.sessionDir,`${W}.stdout.pipe`),H=s(this.sessionDir,`${W}.stderr.pipe`),N=s(this.sessionDir,`${W}.pid`),j=this.escapeShellPath(G),V=this.escapeShellPath(H),D=this.escapeShellPath(J),S=this.escapeShellPath(Q),E=this.escapeShellPath(this.sessionDir),w=this.escapeShellPath(N),F=(l,Z$)=>{let e=" ".repeat(Z$);return l.split(`
`).map((d$)=>d$.length>0?`${e}${d$}`:"").join(`
`)},{setup:x,cleanup:v}=this.buildScopedEnvBlocks(_,W,{restore:!Y}),P=x.length>0,C=(l,Z$)=>{let e=[];if(P)e.push(x);if(e.push(`  ${$}`),e.push(`  ${l}=$?`),v)e.push(v);return F(e.join(`
`),Z$)},A=`{
  log=${D}
  dir=${E}
  sp=${j}
  ep=${V}

`;if(!Y)A+=`  # Cleanup function (foreground only): remove FIFOs if they exist
`,A+=`  cleanup() {
`,A+=`    rm -f "$sp" "$ep"
`,A+=`  }
`,A+=`  trap 'cleanup' EXIT HUP INT TERM
`,A+=`  
`;if(Y)if(A+=`  # Pre-cleanup and create FIFOs with error handling
`,A+=`  rm -f "$sp" "$ep" && mkfifo "$sp" "$ep" || exit 1
`,A+=`  
`,A+=`  # Label stdout with binary prefix in background (capture PID)
`,A+=`  (while IFS= read -r line || [[ -n "$line" ]]; do printf '\\x01\\x01\\x01%s\\n' "$line"; done < "$sp") >> "$log" & r1=$!
`,A+=`  
`,A+=`  # Label stderr with binary prefix in background (capture PID)
`,A+=`  (while IFS= read -r line || [[ -n "$line" ]]; do printf '\\x02\\x02\\x02%s\\n' "$line"; done < "$ep") >> "$log" & r2=$!
`,A+=`  # EOF note: labelers stop when all writers to the FIFOs close.
`,A+=`  # The subshell writing to >"$sp" 2>"$ep" controls EOF; after it exits,
`,A+=`  # we wait for labelers and then remove the FIFOs.
`,A+=`  
`,X){let l=this.escapeShellPath(X);A+=`  # Save and change directory
`,A+=`  PREV_DIR=$(pwd)
`,A+=`  if cd ${l}; then
`,A+=`    # Execute command in BACKGROUND (runs in subshell, enables concurrency)
`,A+=`    {
`,A+=`${C("CMD_EXIT",6)}
`,A+=`      # Write exit code
`,A+=`      echo "$CMD_EXIT" > ${S}.tmp
`,A+=`      mv ${S}.tmp ${S}
`,A+=`    } < /dev/null > "$sp" 2> "$ep" & CMD_PID=$!
`,A+=`    # Write PID for process killing
`,A+=`    echo "$CMD_PID" > ${w}.tmp
`,A+=`    mv ${w}.tmp ${w}
`,A+=`    # Background monitor: waits for labelers to finish (after FIFO EOF)
`,A+=`    # and then removes the FIFOs. PID file is cleaned up by TypeScript.
`,A+=`    (
`,A+=`      wait "$r1" "$r2" 2>/dev/null
`,A+=`      rm -f "$sp" "$ep"
`,A+=`    ) &
`,A+=`    # Restore directory immediately
`,A+=`    cd "$PREV_DIR"
`,A+=`  else
`,A+=`    printf '\\x02\\x02\\x02%s\\n' "Failed to change directory to ${l}" >> "$log"
`,A+=`    EXIT_CODE=1
`,A+=`  fi
`}else A+=`  # Execute command in BACKGROUND (runs in subshell, enables concurrency)
`,A+=`  {
`,A+=`${C("CMD_EXIT",4)}
`,A+=`    # Write exit code
`,A+=`    echo "$CMD_EXIT" > ${S}.tmp
`,A+=`    mv ${S}.tmp ${S}
`,A+=`  } < /dev/null > "$sp" 2> "$ep" & CMD_PID=$!
`,A+=`  # Write PID for process killing
`,A+=`  echo "$CMD_PID" > ${w}.tmp
`,A+=`  mv ${w}.tmp ${w}
`,A+=`  # Background monitor: waits for labelers to finish (after FIFO EOF)
`,A+=`  # and then removes the FIFOs. PID file is cleaned up by TypeScript.
`,A+=`  (
`,A+=`    wait "$r1" "$r2" 2>/dev/null
`,A+=`    rm -f "$sp" "$ep"
`,A+=`  ) &
`;else{if(X){let l=this.escapeShellPath(X);A+=`  # Save and change directory
`,A+=`  PREV_DIR=$(pwd)
`,A+=`  if cd ${l}; then
`,A+=`    # Execute command, redirect to temp files
`,A+=`    {
`,A+=`${C("EXIT_CODE",6)}
`,A+=`    } < /dev/null > "$log.stdout" 2> "$log.stderr"
`,A+=`    # Restore directory
`,A+=`    cd "$PREV_DIR"
`,A+=`  else
`,A+=`    printf '\\x02\\x02\\x02%s\\n' "Failed to change directory to ${l}" >> "$log"
`,A+=`    EXIT_CODE=1
`,A+=`  fi
`}else A+=`  # Execute command, redirect to temp files
`,A+=`  {
`,A+=`${C("EXIT_CODE",4)}
`,A+=`  } < /dev/null > "$log.stdout" 2> "$log.stderr"
`;A+=`  
`,A+=`  # Prefix and merge stdout/stderr into main log
`,A+=`  (while IFS= read -r line || [[ -n "$line" ]]; do printf '\\x01\\x01\\x01%s\\n' "$line"; done < "$log.stdout" >> "$log") 2>/dev/null
`,A+=`  (while IFS= read -r line || [[ -n "$line" ]]; do printf '\\x02\\x02\\x02%s\\n' "$line"; done < "$log.stderr" >> "$log") 2>/dev/null
`,A+=`  rm -f "$log.stdout" "$log.stderr"
`,A+=`  
`,A+=`  # Write exit code
`,A+=`  echo "$EXIT_CODE" > ${S}.tmp
`,A+=`  mv ${S}.tmp ${S}
`}if(!Y)A+=`  
`,A+=`  # Explicit cleanup (redundant with trap, but ensures cleanup)
`,A+=`  cleanup
`;return A+="}",A}buildScopedEnvBlocks($,W,J){if(!$||Object.keys($).length===0)return{setup:"",cleanup:""};let Q=(G)=>G.replace(/[^A-Za-z0-9_]/g,"_"),X=[],Y=[],_=Q(W);return Object.entries($).forEach(([G,H],N)=>{if(!/^[A-Za-z_][A-Za-z0-9_]*$/.test(G))throw Error(`Invalid environment variable name: ${G}`);let j=H.replace(/'/g,"'\\''");if(J.restore){let V=`${_}_${N}`,D=`__SANDBOX_HAS_${V}`,S=`__SANDBOX_PREV_${V}`;X.push(`  ${D}=0`),X.push(`  if [ "\${${G}+x}" = "x" ]; then`),X.push(`    ${D}=1`),X.push(`    ${S}=$(printf '%q' "\${${G}}")`),X.push("  fi"),X.push(`  export ${G}='${j}'`),Y.push(`  if [ "$${D}" = "1" ]; then`),Y.push(`    eval "export ${G}=$${S}"`),Y.push("  else"),Y.push(`    unset ${G}`),Y.push("  fi"),Y.push(`  unset ${D} ${S}`)}else X.push(`  export ${G}='${j}'`)}),{setup:X.join(`
`),cleanup:J.restore?Y.join(`
`):""}}async waitForExitCode($){return new Promise((W,J)=>{let Q=v3($),X=E3($),Y=!1,_=F3(Q,async(H,N)=>{if(Y)return;if(N===X)try{let j=await Bun.file($).text();Y=!0,_.close(),clearInterval(G),W(parseInt(j.trim(),10))}catch{}}),G=setInterval(async()=>{if(Y)return;try{if(await Bun.file($).exists()){Y=!0,_.close(),clearInterval(G);let N=await Bun.file($).text();W(parseInt(N.trim(),10))}}catch(H){}},50);if(this.commandTimeoutMs!==void 0)setTimeout(()=>{if(!Y)Y=!0,_.close(),clearInterval(G),J(Error(`Command timeout after ${this.commandTimeoutMs}ms`))},this.commandTimeoutMs);Bun.file($).exists().then(async(H)=>{if(H&&!Y){Y=!0,_.close(),clearInterval(G);try{let N=await Bun.file($).text();W(parseInt(N.trim(),10))}catch(N){J(Error(`Failed to read exit code: ${N}`))}}}).catch((H)=>{if(!Y)Y=!0,_.close(),clearInterval(G),J(H)})})}async parseLogFile($){let W=Bun.file($);if(!await W.exists())return{stdout:"",stderr:""};let Q=(await W.text()).split(`
`),X=[],Y=[];for(let _ of Q)if(_.startsWith(U$))X.push(_.slice(U$.length));else if(_.startsWith(D$))Y.push(_.slice(D$.length));return{stdout:X.join(`
`),stderr:Y.join(`
`)}}async cleanupCommandFiles($,W){let J=$.replace(".log",".pid");try{await t$($,{force:!0})}catch(Q){}try{await t$(W,{force:!0})}catch(Q){}try{await t$(J,{force:!0})}catch(Q){}}escapeShellPath($){return`'${$.replace(/'/g,"'\\''")}'`}ensureReady(){if(!this.isReady())throw Error(`Session '${this.id}' is not ready or shell has died`)}trackCommand($,W,J,Q){let X={commandId:$,pidFile:W,logFile:J,exitCodeFile:Q};this.runningCommands.set($,X)}untrackCommand($){this.runningCommands.delete($)}}class kW{logger;sessions=new Map;constructor($){this.logger=$}async createSession($){try{if(this.sessions.has($.id))return{success:!1,error:{message:`Session '${$.id}' already exists`,code:B.INTERNAL_ERROR,details:{sessionId:$.id,originalError:"Session already exists"}}};let W=new fW({...$,logger:this.logger});return await W.initialize(),this.sessions.set($.id,W),{success:!0,data:W}}catch(W){let J=W instanceof Error?W.message:"Unknown error",Q=W instanceof Error?W.stack:void 0;return this.logger.error("Failed to create session",W instanceof Error?W:void 0,{sessionId:$.id,originalError:J}),{success:!1,error:{message:`Failed to create session '${$.id}': ${J}`,code:B.INTERNAL_ERROR,details:{sessionId:$.id,originalError:J,stack:Q}}}}}async getSession($){let W=this.sessions.get($);if(!W)return{success:!1,error:{message:`Session '${$}' not found`,code:B.INTERNAL_ERROR,details:{sessionId:$,originalError:"Session not found"}}};return{success:!0,data:W}}async executeInSession($,W,J,Q,X){try{let Y=await this.getSession($);if(!Y.success&&Y.error.details?.originalError==="Session not found")Y=await this.createSession({id:$,cwd:J||"/workspace",commandTimeoutMs:Q});if(!Y.success)return Y;return{success:!0,data:await Y.data.exec(W,J||X?{cwd:J,env:X}:void 0)}}catch(Y){let _=Y instanceof Error?Y.message:"Unknown error";return this.logger.error("Failed to execute command",Y instanceof Error?Y:void 0,{sessionId:$,command:W}),{success:!1,error:{message:`Failed to execute command '${W}' in session '${$}': ${_}`,code:B.COMMAND_EXECUTION_ERROR,details:{command:W,stderr:_}}}}}async executeStreamInSession($,W,J,Q={},X){try{let{cwd:Y,env:_}=Q,G=await this.getSession($);if(!G.success&&G.error.details?.originalError==="Session not found")G=await this.createSession({id:$,cwd:Y||"/workspace"});if(!G.success)return G;let N=G.data.execStream(W,{commandId:X,cwd:Y,env:_}),j=await N.next();if(!j.done)await J(j.value);return{success:!0,data:{continueStreaming:(async()=>{try{for await(let D of N)await J(D)}catch(D){let S=D instanceof Error?D.message:"Unknown error";throw this.logger.error("Error during streaming",D instanceof Error?D:void 0,{sessionId:$,commandId:X,originalError:S}),D}})()}}}catch(Y){let _=Y instanceof Error?Y.message:"Unknown error";return this.logger.error("Failed to execute streaming command",Y instanceof Error?Y:void 0,{sessionId:$,command:W}),{success:!1,error:{message:`Failed to execute streaming command '${W}' in session '${$}': ${_}`,code:B.STREAM_START_ERROR,details:{command:W,stderr:_}}}}}async killCommand($,W){try{let J=await this.getSession($);if(!J.success)return J;if(!await J.data.killCommand(W))return{success:!1,error:{message:`Command '${W}' not found or already completed in session '${$}'`,code:B.COMMAND_NOT_FOUND,details:{command:W}}};return{success:!0}}catch(J){let Q=J instanceof Error?J.message:"Unknown error";return this.logger.error("Failed to kill command",J instanceof Error?J:void 0,{sessionId:$,commandId:W}),{success:!1,error:{message:`Failed to kill command '${W}' in session '${$}': ${Q}`,code:B.PROCESS_ERROR,details:{processId:W,stderr:Q}}}}}async setEnvVars($,W){try{let J=await this.getSession($);if(!J.success&&J.error.details?.originalError==="Session not found")J=await this.createSession({id:$,cwd:"/workspace"});if(!J.success)return J;let Q=J.data;for(let[X,Y]of Object.entries(W)){let _=Y.replace(/'/g,"'\\''"),G=`export ${X}='${_}'`,H=await Q.exec(G);if(H.exitCode!==0)return{success:!1,error:{message:`Failed to set environment variable '${X}' in session '${$}': ${H.stderr}`,code:B.COMMAND_EXECUTION_ERROR,details:{command:`export ${X}='...'`,exitCode:H.exitCode,stderr:H.stderr}}}}return{success:!0}}catch(J){let Q=J instanceof Error?J.message:"Unknown error";return this.logger.error("Failed to set environment variables",J instanceof Error?J:void 0,{sessionId:$}),{success:!1,error:{message:`Failed to set environment variables in session '${$}': ${Q}`,code:B.COMMAND_EXECUTION_ERROR,details:{command:"export",stderr:Q}}}}}async deleteSession($){try{let W=this.sessions.get($);if(!W)return{success:!1,error:{message:`Session '${$}' not found`,code:B.INTERNAL_ERROR,details:{sessionId:$,originalError:"Session not found"}}};return await W.destroy(),this.sessions.delete($),{success:!0}}catch(W){let J=W instanceof Error?W.message:"Unknown error";return this.logger.error("Failed to delete session",W instanceof Error?W:void 0,{sessionId:$}),{success:!1,error:{message:`Failed to delete session '${$}': ${J}`,code:B.INTERNAL_ERROR,details:{sessionId:$,originalError:J}}}}}async listSessions(){try{return{success:!0,data:Array.from(this.sessions.keys())}}catch($){let W=$ instanceof Error?$.message:"Unknown error";return this.logger.error("Failed to list sessions",$ instanceof Error?$:void 0),{success:!1,error:{message:`Failed to list sessions: ${W}`,code:B.INTERNAL_ERROR,details:{originalError:W}}}}}async destroy(){for(let[$,W]of this.sessions.entries())try{await W.destroy()}catch(J){this.logger.error("Failed to destroy session",J instanceof Error?J:void 0,{sessionId:$})}this.sessions.clear()}}var U={};G3(U,{void:()=>V8,util:()=>k,unknown:()=>A8,union:()=>D8,undefined:()=>B8,tuple:()=>w8,transformer:()=>T8,symbol:()=>H8,string:()=>oW,strictObject:()=>U8,setErrorMap:()=>P3,set:()=>q8,record:()=>L8,quotelessJson:()=>T3,promise:()=>v8,preprocess:()=>I8,pipeline:()=>Z8,ostring:()=>y8,optional:()=>C8,onumber:()=>g8,oboolean:()=>h8,objectUtil:()=>EW,object:()=>K8,number:()=>tW,nullable:()=>P8,null:()=>N8,never:()=>O8,nativeEnum:()=>E8,nan:()=>Y8,map:()=>R8,makeIssue:()=>h$,literal:()=>f8,lazy:()=>F8,late:()=>Q8,isValid:()=>Y$,isDirty:()=>e$,isAsync:()=>S$,isAborted:()=>r$,intersection:()=>S8,instanceof:()=>X8,getParsedType:()=>o,getErrorMap:()=>M$,function:()=>b8,enum:()=>k8,effect:()=>T8,discriminatedUnion:()=>M8,defaultErrorMap:()=>W$,datetimeRegex:()=>nW,date:()=>G8,custom:()=>sW,coerce:()=>m8,boolean:()=>rW,bigint:()=>_8,array:()=>z8,any:()=>j8,addIssueToContext:()=>K,ZodVoid:()=>x$,ZodUnknown:()=>_$,ZodUnion:()=>F$,ZodUndefined:()=>q$,ZodType:()=>b,ZodTuple:()=>r,ZodTransformer:()=>n,ZodSymbol:()=>m$,ZodString:()=>p,ZodSet:()=>V$,ZodSchema:()=>b,ZodRecord:()=>l$,ZodReadonly:()=>P$,ZodPromise:()=>z$,ZodPipeline:()=>c$,ZodParsedType:()=>z,ZodOptional:()=>d,ZodObject:()=>T,ZodNumber:()=>G$,ZodNullable:()=>Q$,ZodNull:()=>b$,ZodNever:()=>t,ZodNativeEnum:()=>v$,ZodNaN:()=>p$,ZodMap:()=>u$,ZodLiteral:()=>E$,ZodLazy:()=>k$,ZodIssueCode:()=>O,ZodIntersection:()=>f$,ZodFunction:()=>L$,ZodFirstPartyTypeKind:()=>R,ZodError:()=>u,ZodEnum:()=>B$,ZodEffects:()=>n,ZodDiscriminatedUnion:()=>$W,ZodDefault:()=>T$,ZodDate:()=>A$,ZodCatch:()=>C$,ZodBranded:()=>WW,ZodBoolean:()=>R$,ZodBigInt:()=>H$,ZodArray:()=>c,ZodAny:()=>O$,Schema:()=>b,ParseStatus:()=>y,OK:()=>m,NEVER:()=>x8,INVALID:()=>L,EMPTY_PATH:()=>I3,DIRTY:()=>j$,BRAND:()=>J8});var k;(function($){$.assertEqual=(X)=>{};function W(X){}$.assertIs=W;function J(X){throw Error()}$.assertNever=J,$.arrayToEnum=(X)=>{let Y={};for(let _ of X)Y[_]=_;return Y},$.getValidEnumValues=(X)=>{let Y=$.objectKeys(X).filter((G)=>typeof X[X[G]]!=="number"),_={};for(let G of Y)_[G]=X[G];return $.objectValues(_)},$.objectValues=(X)=>{return $.objectKeys(X).map(function(Y){return X[Y]})},$.objectKeys=typeof Object.keys==="function"?(X)=>Object.keys(X):(X)=>{let Y=[];for(let _ in X)if(Object.prototype.hasOwnProperty.call(X,_))Y.push(_);return Y},$.find=(X,Y)=>{for(let _ of X)if(Y(_))return _;return},$.isInteger=typeof Number.isInteger==="function"?(X)=>Number.isInteger(X):(X)=>typeof X==="number"&&Number.isFinite(X)&&Math.floor(X)===X;function Q(X,Y=" | "){return X.map((_)=>typeof _==="string"?`'${_}'`:_).join(Y)}$.joinValues=Q,$.jsonStringifyReplacer=(X,Y)=>{if(typeof Y==="bigint")return Y.toString();return Y}})(k||(k={}));var EW;(function($){$.mergeShapes=(W,J)=>{return{...W,...J}}})(EW||(EW={}));var z=k.arrayToEnum(["string","nan","number","integer","float","boolean","date","bigint","symbol","function","undefined","null","array","object","unknown","promise","void","never","map","set"]),o=($)=>{switch(typeof $){case"undefined":return z.undefined;case"string":return z.string;case"number":return Number.isNaN($)?z.nan:z.number;case"boolean":return z.boolean;case"function":return z.function;case"bigint":return z.bigint;case"symbol":return z.symbol;case"object":if(Array.isArray($))return z.array;if($===null)return z.null;if($.then&&typeof $.then==="function"&&$.catch&&typeof $.catch==="function")return z.promise;if(typeof Map<"u"&&$ instanceof Map)return z.map;if(typeof Set<"u"&&$ instanceof Set)return z.set;if(typeof Date<"u"&&$ instanceof Date)return z.date;return z.object;default:return z.unknown}};var O=k.arrayToEnum(["invalid_type","invalid_literal","custom","invalid_union","invalid_union_discriminator","invalid_enum_value","unrecognized_keys","invalid_arguments","invalid_return_type","invalid_date","invalid_string","too_small","too_big","invalid_intersection_types","not_multiple_of","not_finite"]),T3=($)=>{return JSON.stringify($,null,2).replace(/"([^"]+)":/g,"$1:")};class u extends Error{get errors(){return this.issues}constructor($){super();this.issues=[],this.addIssue=(J)=>{this.issues=[...this.issues,J]},this.addIssues=(J=[])=>{this.issues=[...this.issues,...J]};let W=new.target.prototype;if(Object.setPrototypeOf)Object.setPrototypeOf(this,W);else this.__proto__=W;this.name="ZodError",this.issues=$}format($){let W=$||function(X){return X.message},J={_errors:[]},Q=(X)=>{for(let Y of X.issues)if(Y.code==="invalid_union")Y.unionErrors.map(Q);else if(Y.code==="invalid_return_type")Q(Y.returnTypeError);else if(Y.code==="invalid_arguments")Q(Y.argumentsError);else if(Y.path.length===0)J._errors.push(W(Y));else{let _=J,G=0;while(G<Y.path.length){let H=Y.path[G];if(G!==Y.path.length-1)_[H]=_[H]||{_errors:[]};else _[H]=_[H]||{_errors:[]},_[H]._errors.push(W(Y));_=_[H],G++}}};return Q(this),J}static assert($){if(!($ instanceof u))throw Error(`Not a ZodError: ${$}`)}toString(){return this.message}get message(){return JSON.stringify(this.issues,k.jsonStringifyReplacer,2)}get isEmpty(){return this.issues.length===0}flatten($=(W)=>W.message){let W={},J=[];for(let Q of this.issues)if(Q.path.length>0){let X=Q.path[0];W[X]=W[X]||[],W[X].push($(Q))}else J.push($(Q));return{formErrors:J,fieldErrors:W}}get formErrors(){return this.flatten()}}u.create=($)=>{return new u($)};var C3=($,W)=>{let J;switch($.code){case O.invalid_type:if($.received===z.undefined)J="Required";else J=`Expected ${$.expected}, received ${$.received}`;break;case O.invalid_literal:J=`Invalid literal value, expected ${JSON.stringify($.expected,k.jsonStringifyReplacer)}`;break;case O.unrecognized_keys:J=`Unrecognized key(s) in object: ${k.joinValues($.keys,", ")}`;break;case O.invalid_union:J="Invalid input";break;case O.invalid_union_discriminator:J=`Invalid discriminator value. Expected ${k.joinValues($.options)}`;break;case O.invalid_enum_value:J=`Invalid enum value. Expected ${k.joinValues($.options)}, received '${$.received}'`;break;case O.invalid_arguments:J="Invalid function arguments";break;case O.invalid_return_type:J="Invalid function return type";break;case O.invalid_date:J="Invalid date";break;case O.invalid_string:if(typeof $.validation==="object")if("includes"in $.validation){if(J=`Invalid input: must include "${$.validation.includes}"`,typeof $.validation.position==="number")J=`${J} at one or more positions greater than or equal to ${$.validation.position}`}else if("startsWith"in $.validation)J=`Invalid input: must start with "${$.validation.startsWith}"`;else if("endsWith"in $.validation)J=`Invalid input: must end with "${$.validation.endsWith}"`;else k.assertNever($.validation);else if($.validation!=="regex")J=`Invalid ${$.validation}`;else J="Invalid";break;case O.too_small:if($.type==="array")J=`Array must contain ${$.exact?"exactly":$.inclusive?"at least":"more than"} ${$.minimum} element(s)`;else if($.type==="string")J=`String must contain ${$.exact?"exactly":$.inclusive?"at least":"over"} ${$.minimum} character(s)`;else if($.type==="number")J=`Number must be ${$.exact?"exactly equal to ":$.inclusive?"greater than or equal to ":"greater than "}${$.minimum}`;else if($.type==="bigint")J=`Number must be ${$.exact?"exactly equal to ":$.inclusive?"greater than or equal to ":"greater than "}${$.minimum}`;else if($.type==="date")J=`Date must be ${$.exact?"exactly equal to ":$.inclusive?"greater than or equal to ":"greater than "}${new Date(Number($.minimum))}`;else J="Invalid input";break;case O.too_big:if($.type==="array")J=`Array must contain ${$.exact?"exactly":$.inclusive?"at most":"less than"} ${$.maximum} element(s)`;else if($.type==="string")J=`String must contain ${$.exact?"exactly":$.inclusive?"at most":"under"} ${$.maximum} character(s)`;else if($.type==="number")J=`Number must be ${$.exact?"exactly":$.inclusive?"less than or equal to":"less than"} ${$.maximum}`;else if($.type==="bigint")J=`BigInt must be ${$.exact?"exactly":$.inclusive?"less than or equal to":"less than"} ${$.maximum}`;else if($.type==="date")J=`Date must be ${$.exact?"exactly":$.inclusive?"smaller than or equal to":"smaller than"} ${new Date(Number($.maximum))}`;else J="Invalid input";break;case O.custom:J="Invalid input";break;case O.invalid_intersection_types:J="Intersection results could not be merged";break;case O.not_multiple_of:J=`Number must be a multiple of ${$.multipleOf}`;break;case O.not_finite:J="Number must be finite";break;default:J=W.defaultError,k.assertNever($)}return{message:J}},W$=C3;var uW=W$;function P3($){uW=$}function M$(){return uW}var h$=($)=>{let{data:W,path:J,errorMaps:Q,issueData:X}=$,Y=[...J,...X.path||[]],_={...X,path:Y};if(X.message!==void 0)return{...X,path:Y,message:X.message};let G="",H=Q.filter((N)=>!!N).slice().reverse();for(let N of H)G=N(_,{data:W,defaultError:G}).message;return{...X,path:Y,message:G}},I3=[];function K($,W){let J=M$(),Q=h$({issueData:W,data:$.data,path:$.path,errorMaps:[$.common.contextualErrorMap,$.schemaErrorMap,J,J===W$?void 0:W$].filter((X)=>!!X)});$.common.issues.push(Q)}class y{constructor(){this.value="valid"}dirty(){if(this.value==="valid")this.value="dirty"}abort(){if(this.value!=="aborted")this.value="aborted"}static mergeArray($,W){let J=[];for(let Q of W){if(Q.status==="aborted")return L;if(Q.status==="dirty")$.dirty();J.push(Q.value)}return{status:$.value,value:J}}static async mergeObjectAsync($,W){let J=[];for(let Q of W){let X=await Q.key,Y=await Q.value;J.push({key:X,value:Y})}return y.mergeObjectSync($,J)}static mergeObjectSync($,W){let J={};for(let Q of W){let{key:X,value:Y}=Q;if(X.status==="aborted")return L;if(Y.status==="aborted")return L;if(X.status==="dirty")$.dirty();if(Y.status==="dirty")$.dirty();if(X.value!=="__proto__"&&(typeof Y.value<"u"||Q.alwaysSet))J[X.value]=Y.value}return{status:$.value,value:J}}}var L=Object.freeze({status:"aborted"}),j$=($)=>({status:"dirty",value:$}),m=($)=>({status:"valid",value:$}),r$=($)=>$.status==="aborted",e$=($)=>$.status==="dirty",Y$=($)=>$.status==="valid",S$=($)=>typeof Promise<"u"&&$ instanceof Promise;var M;(function($){$.errToObj=(W)=>typeof W==="string"?{message:W}:W||{},$.toString=(W)=>typeof W==="string"?W:W?.message})(M||(M={}));class i{constructor($,W,J,Q){this._cachedPath=[],this.parent=$,this.data=W,this._path=J,this._key=Q}get path(){if(!this._cachedPath.length)if(Array.isArray(this._key))this._cachedPath.push(...this._path,...this._key);else this._cachedPath.push(...this._path,this._key);return this._cachedPath}}var pW=($,W)=>{if(Y$(W))return{success:!0,data:W.value};else{if(!$.common.issues.length)throw Error("Validation failed but no issues detected.");return{success:!1,get error(){if(this._error)return this._error;let J=new u($.common.issues);return this._error=J,this._error}}}};function q($){if(!$)return{};let{errorMap:W,invalid_type_error:J,required_error:Q,description:X}=$;if(W&&(J||Q))throw Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);if(W)return{errorMap:W,description:X};return{errorMap:(_,G)=>{let{message:H}=$;if(_.code==="invalid_enum_value")return{message:H??G.defaultError};if(typeof G.data>"u")return{message:H??Q??G.defaultError};if(_.code!=="invalid_type")return{message:G.defaultError};return{message:H??J??G.defaultError}},description:X}}class b{get description(){return this._def.description}_getType($){return o($.data)}_getOrReturnCtx($,W){return W||{common:$.parent.common,data:$.data,parsedType:o($.data),schemaErrorMap:this._def.errorMap,path:$.path,parent:$.parent}}_processInputParams($){return{status:new y,ctx:{common:$.parent.common,data:$.data,parsedType:o($.data),schemaErrorMap:this._def.errorMap,path:$.path,parent:$.parent}}}_parseSync($){let W=this._parse($);if(S$(W))throw Error("Synchronous parse encountered promise.");return W}_parseAsync($){let W=this._parse($);return Promise.resolve(W)}parse($,W){let J=this.safeParse($,W);if(J.success)return J.data;throw J.error}safeParse($,W){let J={common:{issues:[],async:W?.async??!1,contextualErrorMap:W?.errorMap},path:W?.path||[],schemaErrorMap:this._def.errorMap,parent:null,data:$,parsedType:o($)},Q=this._parseSync({data:$,path:J.path,parent:J});return pW(J,Q)}"~validate"($){let W={common:{issues:[],async:!!this["~standard"].async},path:[],schemaErrorMap:this._def.errorMap,parent:null,data:$,parsedType:o($)};if(!this["~standard"].async)try{let J=this._parseSync({data:$,path:[],parent:W});return Y$(J)?{value:J.value}:{issues:W.common.issues}}catch(J){if(J?.message?.toLowerCase()?.includes("encountered"))this["~standard"].async=!0;W.common={issues:[],async:!0}}return this._parseAsync({data:$,path:[],parent:W}).then((J)=>Y$(J)?{value:J.value}:{issues:W.common.issues})}async parseAsync($,W){let J=await this.safeParseAsync($,W);if(J.success)return J.data;throw J.error}async safeParseAsync($,W){let J={common:{issues:[],contextualErrorMap:W?.errorMap,async:!0},path:W?.path||[],schemaErrorMap:this._def.errorMap,parent:null,data:$,parsedType:o($)},Q=this._parse({data:$,path:J.path,parent:J}),X=await(S$(Q)?Q:Promise.resolve(Q));return pW(J,X)}refine($,W){let J=(Q)=>{if(typeof W==="string"||typeof W>"u")return{message:W};else if(typeof W==="function")return W(Q);else return W};return this._refinement((Q,X)=>{let Y=$(Q),_=()=>X.addIssue({code:O.custom,...J(Q)});if(typeof Promise<"u"&&Y instanceof Promise)return Y.then((G)=>{if(!G)return _(),!1;else return!0});if(!Y)return _(),!1;else return!0})}refinement($,W){return this._refinement((J,Q)=>{if(!$(J))return Q.addIssue(typeof W==="function"?W(J,Q):W),!1;else return!0})}_refinement($){return new n({schema:this,typeName:R.ZodEffects,effect:{type:"refinement",refinement:$}})}superRefine($){return this._refinement($)}constructor($){this.spa=this.safeParseAsync,this._def=$,this.parse=this.parse.bind(this),this.safeParse=this.safeParse.bind(this),this.parseAsync=this.parseAsync.bind(this),this.safeParseAsync=this.safeParseAsync.bind(this),this.spa=this.spa.bind(this),this.refine=this.refine.bind(this),this.refinement=this.refinement.bind(this),this.superRefine=this.superRefine.bind(this),this.optional=this.optional.bind(this),this.nullable=this.nullable.bind(this),this.nullish=this.nullish.bind(this),this.array=this.array.bind(this),this.promise=this.promise.bind(this),this.or=this.or.bind(this),this.and=this.and.bind(this),this.transform=this.transform.bind(this),this.brand=this.brand.bind(this),this.default=this.default.bind(this),this.catch=this.catch.bind(this),this.describe=this.describe.bind(this),this.pipe=this.pipe.bind(this),this.readonly=this.readonly.bind(this),this.isNullable=this.isNullable.bind(this),this.isOptional=this.isOptional.bind(this),this["~standard"]={version:1,vendor:"zod",validate:(W)=>this["~validate"](W)}}optional(){return d.create(this,this._def)}nullable(){return Q$.create(this,this._def)}nullish(){return this.nullable().optional()}array(){return c.create(this)}promise(){return z$.create(this,this._def)}or($){return F$.create([this,$],this._def)}and($){return f$.create(this,$,this._def)}transform($){return new n({...q(this._def),schema:this,typeName:R.ZodEffects,effect:{type:"transform",transform:$}})}default($){let W=typeof $==="function"?$:()=>$;return new T$({...q(this._def),innerType:this,defaultValue:W,typeName:R.ZodDefault})}brand(){return new WW({typeName:R.ZodBranded,type:this,...q(this._def)})}catch($){let W=typeof $==="function"?$:()=>$;return new C$({...q(this._def),innerType:this,catchValue:W,typeName:R.ZodCatch})}describe($){return new this.constructor({...this._def,description:$})}pipe($){return c$.create(this,$)}readonly(){return P$.create(this)}isOptional(){return this.safeParse(void 0).success}isNullable(){return this.safeParse(null).success}}var Z3=/^c[^\s-]{8,}$/i,y3=/^[0-9a-z]+$/,g3=/^[0-9A-HJKMNP-TV-Z]{26}$/i,h3=/^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,m3=/^[a-z0-9_-]{21}$/i,x3=/^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,l3=/^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,u3=/^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,p3="^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",vW,c3=/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,d3=/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,i3=/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/,n3=/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,a3=/^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,s3=/^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,dW="((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",o3=new RegExp(`^${dW}$`);function iW($){let W="[0-5]\\d";if($.precision)W=`${W}\\.\\d{${$.precision}}`;else if($.precision==null)W=`${W}(\\.\\d+)?`;let J=$.precision?"+":"?";return`([01]\\d|2[0-3]):[0-5]\\d(:${W})${J}`}function t3($){return new RegExp(`^${iW($)}$`)}function nW($){let W=`${dW}T${iW($)}`,J=[];if(J.push($.local?"Z?":"Z"),$.offset)J.push("([+-]\\d{2}:?\\d{2})");return W=`${W}(${J.join("|")})`,new RegExp(`^${W}$`)}function r3($,W){if((W==="v4"||!W)&&c3.test($))return!0;if((W==="v6"||!W)&&i3.test($))return!0;return!1}function e3($,W){if(!x3.test($))return!1;try{let[J]=$.split(".");if(!J)return!1;let Q=J.replace(/-/g,"+").replace(/_/g,"/").padEnd(J.length+(4-J.length%4)%4,"="),X=JSON.parse(atob(Q));if(typeof X!=="object"||X===null)return!1;if("typ"in X&&X?.typ!=="JWT")return!1;if(!X.alg)return!1;if(W&&X.alg!==W)return!1;return!0}catch{return!1}}function $8($,W){if((W==="v4"||!W)&&d3.test($))return!0;if((W==="v6"||!W)&&n3.test($))return!0;return!1}class p extends b{_parse($){if(this._def.coerce)$.data=String($.data);if(this._getType($)!==z.string){let X=this._getOrReturnCtx($);return K(X,{code:O.invalid_type,expected:z.string,received:X.parsedType}),L}let J=new y,Q=void 0;for(let X of this._def.checks)if(X.kind==="min"){if($.data.length<X.value)Q=this._getOrReturnCtx($,Q),K(Q,{code:O.too_small,minimum:X.value,type:"string",inclusive:!0,exact:!1,message:X.message}),J.dirty()}else if(X.kind==="max"){if($.data.length>X.value)Q=this._getOrReturnCtx($,Q),K(Q,{code:O.too_big,maximum:X.value,type:"string",inclusive:!0,exact:!1,message:X.message}),J.dirty()}else if(X.kind==="length"){let Y=$.data.length>X.value,_=$.data.length<X.value;if(Y||_){if(Q=this._getOrReturnCtx($,Q),Y)K(Q,{code:O.too_big,maximum:X.value,type:"string",inclusive:!0,exact:!0,message:X.message});else if(_)K(Q,{code:O.too_small,minimum:X.value,type:"string",inclusive:!0,exact:!0,message:X.message});J.dirty()}}else if(X.kind==="email"){if(!u3.test($.data))Q=this._getOrReturnCtx($,Q),K(Q,{validation:"email",code:O.invalid_string,message:X.message}),J.dirty()}else if(X.kind==="emoji"){if(!vW)vW=new RegExp(p3,"u");if(!vW.test($.data))Q=this._getOrReturnCtx($,Q),K(Q,{validation:"emoji",code:O.invalid_string,message:X.message}),J.dirty()}else if(X.kind==="uuid"){if(!h3.test($.data))Q=this._getOrReturnCtx($,Q),K(Q,{validation:"uuid",code:O.invalid_string,message:X.message}),J.dirty()}else if(X.kind==="nanoid"){if(!m3.test($.data))Q=this._getOrReturnCtx($,Q),K(Q,{validation:"nanoid",code:O.invalid_string,message:X.message}),J.dirty()}else if(X.kind==="cuid"){if(!Z3.test($.data))Q=this._getOrReturnCtx($,Q),K(Q,{validation:"cuid",code:O.invalid_string,message:X.message}),J.dirty()}else if(X.kind==="cuid2"){if(!y3.test($.data))Q=this._getOrReturnCtx($,Q),K(Q,{validation:"cuid2",code:O.invalid_string,message:X.message}),J.dirty()}else if(X.kind==="ulid"){if(!g3.test($.data))Q=this._getOrReturnCtx($,Q),K(Q,{validation:"ulid",code:O.invalid_string,message:X.message}),J.dirty()}else if(X.kind==="url")try{new URL($.data)}catch{Q=this._getOrReturnCtx($,Q),K(Q,{validation:"url",code:O.invalid_string,message:X.message}),J.dirty()}else if(X.kind==="regex"){if(X.regex.lastIndex=0,!X.regex.test($.data))Q=this._getOrReturnCtx($,Q),K(Q,{validation:"regex",code:O.invalid_string,message:X.message}),J.dirty()}else if(X.kind==="trim")$.data=$.data.trim();else if(X.kind==="includes"){if(!$.data.includes(X.value,X.position))Q=this._getOrReturnCtx($,Q),K(Q,{code:O.invalid_string,validation:{includes:X.value,position:X.position},message:X.message}),J.dirty()}else if(X.kind==="toLowerCase")$.data=$.data.toLowerCase();else if(X.kind==="toUpperCase")$.data=$.data.toUpperCase();else if(X.kind==="startsWith"){if(!$.data.startsWith(X.value))Q=this._getOrReturnCtx($,Q),K(Q,{code:O.invalid_string,validation:{startsWith:X.value},message:X.message}),J.dirty()}else if(X.kind==="endsWith"){if(!$.data.endsWith(X.value))Q=this._getOrReturnCtx($,Q),K(Q,{code:O.invalid_string,validation:{endsWith:X.value},message:X.message}),J.dirty()}else if(X.kind==="datetime"){if(!nW(X).test($.data))Q=this._getOrReturnCtx($,Q),K(Q,{code:O.invalid_string,validation:"datetime",message:X.message}),J.dirty()}else if(X.kind==="date"){if(!o3.test($.data))Q=this._getOrReturnCtx($,Q),K(Q,{code:O.invalid_string,validation:"date",message:X.message}),J.dirty()}else if(X.kind==="time"){if(!t3(X).test($.data))Q=this._getOrReturnCtx($,Q),K(Q,{code:O.invalid_string,validation:"time",message:X.message}),J.dirty()}else if(X.kind==="duration"){if(!l3.test($.data))Q=this._getOrReturnCtx($,Q),K(Q,{validation:"duration",code:O.invalid_string,message:X.message}),J.dirty()}else if(X.kind==="ip"){if(!r3($.data,X.version))Q=this._getOrReturnCtx($,Q),K(Q,{validation:"ip",code:O.invalid_string,message:X.message}),J.dirty()}else if(X.kind==="jwt"){if(!e3($.data,X.alg))Q=this._getOrReturnCtx($,Q),K(Q,{validation:"jwt",code:O.invalid_string,message:X.message}),J.dirty()}else if(X.kind==="cidr"){if(!$8($.data,X.version))Q=this._getOrReturnCtx($,Q),K(Q,{validation:"cidr",code:O.invalid_string,message:X.message}),J.dirty()}else if(X.kind==="base64"){if(!a3.test($.data))Q=this._getOrReturnCtx($,Q),K(Q,{validation:"base64",code:O.invalid_string,message:X.message}),J.dirty()}else if(X.kind==="base64url"){if(!s3.test($.data))Q=this._getOrReturnCtx($,Q),K(Q,{validation:"base64url",code:O.invalid_string,message:X.message}),J.dirty()}else k.assertNever(X);return{status:J.value,value:$.data}}_regex($,W,J){return this.refinement((Q)=>$.test(Q),{validation:W,code:O.invalid_string,...M.errToObj(J)})}_addCheck($){return new p({...this._def,checks:[...this._def.checks,$]})}email($){return this._addCheck({kind:"email",...M.errToObj($)})}url($){return this._addCheck({kind:"url",...M.errToObj($)})}emoji($){return this._addCheck({kind:"emoji",...M.errToObj($)})}uuid($){return this._addCheck({kind:"uuid",...M.errToObj($)})}nanoid($){return this._addCheck({kind:"nanoid",...M.errToObj($)})}cuid($){return this._addCheck({kind:"cuid",...M.errToObj($)})}cuid2($){return this._addCheck({kind:"cuid2",...M.errToObj($)})}ulid($){return this._addCheck({kind:"ulid",...M.errToObj($)})}base64($){return this._addCheck({kind:"base64",...M.errToObj($)})}base64url($){return this._addCheck({kind:"base64url",...M.errToObj($)})}jwt($){return this._addCheck({kind:"jwt",...M.errToObj($)})}ip($){return this._addCheck({kind:"ip",...M.errToObj($)})}cidr($){return this._addCheck({kind:"cidr",...M.errToObj($)})}datetime($){if(typeof $==="string")return this._addCheck({kind:"datetime",precision:null,offset:!1,local:!1,message:$});return this._addCheck({kind:"datetime",precision:typeof $?.precision>"u"?null:$?.precision,offset:$?.offset??!1,local:$?.local??!1,...M.errToObj($?.message)})}date($){return this._addCheck({kind:"date",message:$})}time($){if(typeof $==="string")return this._addCheck({kind:"time",precision:null,message:$});return this._addCheck({kind:"time",precision:typeof $?.precision>"u"?null:$?.precision,...M.errToObj($?.message)})}duration($){return this._addCheck({kind:"duration",...M.errToObj($)})}regex($,W){return this._addCheck({kind:"regex",regex:$,...M.errToObj(W)})}includes($,W){return this._addCheck({kind:"includes",value:$,position:W?.position,...M.errToObj(W?.message)})}startsWith($,W){return this._addCheck({kind:"startsWith",value:$,...M.errToObj(W)})}endsWith($,W){return this._addCheck({kind:"endsWith",value:$,...M.errToObj(W)})}min($,W){return this._addCheck({kind:"min",value:$,...M.errToObj(W)})}max($,W){return this._addCheck({kind:"max",value:$,...M.errToObj(W)})}length($,W){return this._addCheck({kind:"length",value:$,...M.errToObj(W)})}nonempty($){return this.min(1,M.errToObj($))}trim(){return new p({...this._def,checks:[...this._def.checks,{kind:"trim"}]})}toLowerCase(){return new p({...this._def,checks:[...this._def.checks,{kind:"toLowerCase"}]})}toUpperCase(){return new p({...this._def,checks:[...this._def.checks,{kind:"toUpperCase"}]})}get isDatetime(){return!!this._def.checks.find(($)=>$.kind==="datetime")}get isDate(){return!!this._def.checks.find(($)=>$.kind==="date")}get isTime(){return!!this._def.checks.find(($)=>$.kind==="time")}get isDuration(){return!!this._def.checks.find(($)=>$.kind==="duration")}get isEmail(){return!!this._def.checks.find(($)=>$.kind==="email")}get isURL(){return!!this._def.checks.find(($)=>$.kind==="url")}get isEmoji(){return!!this._def.checks.find(($)=>$.kind==="emoji")}get isUUID(){return!!this._def.checks.find(($)=>$.kind==="uuid")}get isNANOID(){return!!this._def.checks.find(($)=>$.kind==="nanoid")}get isCUID(){return!!this._def.checks.find(($)=>$.kind==="cuid")}get isCUID2(){return!!this._def.checks.find(($)=>$.kind==="cuid2")}get isULID(){return!!this._def.checks.find(($)=>$.kind==="ulid")}get isIP(){return!!this._def.checks.find(($)=>$.kind==="ip")}get isCIDR(){return!!this._def.checks.find(($)=>$.kind==="cidr")}get isBase64(){return!!this._def.checks.find(($)=>$.kind==="base64")}get isBase64url(){return!!this._def.checks.find(($)=>$.kind==="base64url")}get minLength(){let $=null;for(let W of this._def.checks)if(W.kind==="min"){if($===null||W.value>$)$=W.value}return $}get maxLength(){let $=null;for(let W of this._def.checks)if(W.kind==="max"){if($===null||W.value<$)$=W.value}return $}}p.create=($)=>{return new p({checks:[],typeName:R.ZodString,coerce:$?.coerce??!1,...q($)})};function W8($,W){let J=($.toString().split(".")[1]||"").length,Q=(W.toString().split(".")[1]||"").length,X=J>Q?J:Q,Y=Number.parseInt($.toFixed(X).replace(".","")),_=Number.parseInt(W.toFixed(X).replace(".",""));return Y%_/10**X}class G$ extends b{constructor(){super(...arguments);this.min=this.gte,this.max=this.lte,this.step=this.multipleOf}_parse($){if(this._def.coerce)$.data=Number($.data);if(this._getType($)!==z.number){let X=this._getOrReturnCtx($);return K(X,{code:O.invalid_type,expected:z.number,received:X.parsedType}),L}let J=void 0,Q=new y;for(let X of this._def.checks)if(X.kind==="int"){if(!k.isInteger($.data))J=this._getOrReturnCtx($,J),K(J,{code:O.invalid_type,expected:"integer",received:"float",message:X.message}),Q.dirty()}else if(X.kind==="min"){if(X.inclusive?$.data<X.value:$.data<=X.value)J=this._getOrReturnCtx($,J),K(J,{code:O.too_small,minimum:X.value,type:"number",inclusive:X.inclusive,exact:!1,message:X.message}),Q.dirty()}else if(X.kind==="max"){if(X.inclusive?$.data>X.value:$.data>=X.value)J=this._getOrReturnCtx($,J),K(J,{code:O.too_big,maximum:X.value,type:"number",inclusive:X.inclusive,exact:!1,message:X.message}),Q.dirty()}else if(X.kind==="multipleOf"){if(W8($.data,X.value)!==0)J=this._getOrReturnCtx($,J),K(J,{code:O.not_multiple_of,multipleOf:X.value,message:X.message}),Q.dirty()}else if(X.kind==="finite"){if(!Number.isFinite($.data))J=this._getOrReturnCtx($,J),K(J,{code:O.not_finite,message:X.message}),Q.dirty()}else k.assertNever(X);return{status:Q.value,value:$.data}}gte($,W){return this.setLimit("min",$,!0,M.toString(W))}gt($,W){return this.setLimit("min",$,!1,M.toString(W))}lte($,W){return this.setLimit("max",$,!0,M.toString(W))}lt($,W){return this.setLimit("max",$,!1,M.toString(W))}setLimit($,W,J,Q){return new G$({...this._def,checks:[...this._def.checks,{kind:$,value:W,inclusive:J,message:M.toString(Q)}]})}_addCheck($){return new G$({...this._def,checks:[...this._def.checks,$]})}int($){return this._addCheck({kind:"int",message:M.toString($)})}positive($){return this._addCheck({kind:"min",value:0,inclusive:!1,message:M.toString($)})}negative($){return this._addCheck({kind:"max",value:0,inclusive:!1,message:M.toString($)})}nonpositive($){return this._addCheck({kind:"max",value:0,inclusive:!0,message:M.toString($)})}nonnegative($){return this._addCheck({kind:"min",value:0,inclusive:!0,message:M.toString($)})}multipleOf($,W){return this._addCheck({kind:"multipleOf",value:$,message:M.toString(W)})}finite($){return this._addCheck({kind:"finite",message:M.toString($)})}safe($){return this._addCheck({kind:"min",inclusive:!0,value:Number.MIN_SAFE_INTEGER,message:M.toString($)})._addCheck({kind:"max",inclusive:!0,value:Number.MAX_SAFE_INTEGER,message:M.toString($)})}get minValue(){let $=null;for(let W of this._def.checks)if(W.kind==="min"){if($===null||W.value>$)$=W.value}return $}get maxValue(){let $=null;for(let W of this._def.checks)if(W.kind==="max"){if($===null||W.value<$)$=W.value}return $}get isInt(){return!!this._def.checks.find(($)=>$.kind==="int"||$.kind==="multipleOf"&&k.isInteger($.value))}get isFinite(){let $=null,W=null;for(let J of this._def.checks)if(J.kind==="finite"||J.kind==="int"||J.kind==="multipleOf")return!0;else if(J.kind==="min"){if(W===null||J.value>W)W=J.value}else if(J.kind==="max"){if($===null||J.value<$)$=J.value}return Number.isFinite(W)&&Number.isFinite($)}}G$.create=($)=>{return new G$({checks:[],typeName:R.ZodNumber,coerce:$?.coerce||!1,...q($)})};class H$ extends b{constructor(){super(...arguments);this.min=this.gte,this.max=this.lte}_parse($){if(this._def.coerce)try{$.data=BigInt($.data)}catch{return this._getInvalidInput($)}if(this._getType($)!==z.bigint)return this._getInvalidInput($);let J=void 0,Q=new y;for(let X of this._def.checks)if(X.kind==="min"){if(X.inclusive?$.data<X.value:$.data<=X.value)J=this._getOrReturnCtx($,J),K(J,{code:O.too_small,type:"bigint",minimum:X.value,inclusive:X.inclusive,message:X.message}),Q.dirty()}else if(X.kind==="max"){if(X.inclusive?$.data>X.value:$.data>=X.value)J=this._getOrReturnCtx($,J),K(J,{code:O.too_big,type:"bigint",maximum:X.value,inclusive:X.inclusive,message:X.message}),Q.dirty()}else if(X.kind==="multipleOf"){if($.data%X.value!==BigInt(0))J=this._getOrReturnCtx($,J),K(J,{code:O.not_multiple_of,multipleOf:X.value,message:X.message}),Q.dirty()}else k.assertNever(X);return{status:Q.value,value:$.data}}_getInvalidInput($){let W=this._getOrReturnCtx($);return K(W,{code:O.invalid_type,expected:z.bigint,received:W.parsedType}),L}gte($,W){return this.setLimit("min",$,!0,M.toString(W))}gt($,W){return this.setLimit("min",$,!1,M.toString(W))}lte($,W){return this.setLimit("max",$,!0,M.toString(W))}lt($,W){return this.setLimit("max",$,!1,M.toString(W))}setLimit($,W,J,Q){return new H$({...this._def,checks:[...this._def.checks,{kind:$,value:W,inclusive:J,message:M.toString(Q)}]})}_addCheck($){return new H$({...this._def,checks:[...this._def.checks,$]})}positive($){return this._addCheck({kind:"min",value:BigInt(0),inclusive:!1,message:M.toString($)})}negative($){return this._addCheck({kind:"max",value:BigInt(0),inclusive:!1,message:M.toString($)})}nonpositive($){return this._addCheck({kind:"max",value:BigInt(0),inclusive:!0,message:M.toString($)})}nonnegative($){return this._addCheck({kind:"min",value:BigInt(0),inclusive:!0,message:M.toString($)})}multipleOf($,W){return this._addCheck({kind:"multipleOf",value:$,message:M.toString(W)})}get minValue(){let $=null;for(let W of this._def.checks)if(W.kind==="min"){if($===null||W.value>$)$=W.value}return $}get maxValue(){let $=null;for(let W of this._def.checks)if(W.kind==="max"){if($===null||W.value<$)$=W.value}return $}}H$.create=($)=>{return new H$({checks:[],typeName:R.ZodBigInt,coerce:$?.coerce??!1,...q($)})};class R$ extends b{_parse($){if(this._def.coerce)$.data=Boolean($.data);if(this._getType($)!==z.boolean){let J=this._getOrReturnCtx($);return K(J,{code:O.invalid_type,expected:z.boolean,received:J.parsedType}),L}return m($.data)}}R$.create=($)=>{return new R$({typeName:R.ZodBoolean,coerce:$?.coerce||!1,...q($)})};class A$ extends b{_parse($){if(this._def.coerce)$.data=new Date($.data);if(this._getType($)!==z.date){let X=this._getOrReturnCtx($);return K(X,{code:O.invalid_type,expected:z.date,received:X.parsedType}),L}if(Number.isNaN($.data.getTime())){let X=this._getOrReturnCtx($);return K(X,{code:O.invalid_date}),L}let J=new y,Q=void 0;for(let X of this._def.checks)if(X.kind==="min"){if($.data.getTime()<X.value)Q=this._getOrReturnCtx($,Q),K(Q,{code:O.too_small,message:X.message,inclusive:!0,exact:!1,minimum:X.value,type:"date"}),J.dirty()}else if(X.kind==="max"){if($.data.getTime()>X.value)Q=this._getOrReturnCtx($,Q),K(Q,{code:O.too_big,message:X.message,inclusive:!0,exact:!1,maximum:X.value,type:"date"}),J.dirty()}else k.assertNever(X);return{status:J.value,value:new Date($.data.getTime())}}_addCheck($){return new A$({...this._def,checks:[...this._def.checks,$]})}min($,W){return this._addCheck({kind:"min",value:$.getTime(),message:M.toString(W)})}max($,W){return this._addCheck({kind:"max",value:$.getTime(),message:M.toString(W)})}get minDate(){let $=null;for(let W of this._def.checks)if(W.kind==="min"){if($===null||W.value>$)$=W.value}return $!=null?new Date($):null}get maxDate(){let $=null;for(let W of this._def.checks)if(W.kind==="max"){if($===null||W.value<$)$=W.value}return $!=null?new Date($):null}}A$.create=($)=>{return new A$({checks:[],coerce:$?.coerce||!1,typeName:R.ZodDate,...q($)})};class m$ extends b{_parse($){if(this._getType($)!==z.symbol){let J=this._getOrReturnCtx($);return K(J,{code:O.invalid_type,expected:z.symbol,received:J.parsedType}),L}return m($.data)}}m$.create=($)=>{return new m$({typeName:R.ZodSymbol,...q($)})};class q$ extends b{_parse($){if(this._getType($)!==z.undefined){let J=this._getOrReturnCtx($);return K(J,{code:O.invalid_type,expected:z.undefined,received:J.parsedType}),L}return m($.data)}}q$.create=($)=>{return new q$({typeName:R.ZodUndefined,...q($)})};class b$ extends b{_parse($){if(this._getType($)!==z.null){let J=this._getOrReturnCtx($);return K(J,{code:O.invalid_type,expected:z.null,received:J.parsedType}),L}return m($.data)}}b$.create=($)=>{return new b$({typeName:R.ZodNull,...q($)})};class O$ extends b{constructor(){super(...arguments);this._any=!0}_parse($){return m($.data)}}O$.create=($)=>{return new O$({typeName:R.ZodAny,...q($)})};class _$ extends b{constructor(){super(...arguments);this._unknown=!0}_parse($){return m($.data)}}_$.create=($)=>{return new _$({typeName:R.ZodUnknown,...q($)})};class t extends b{_parse($){let W=this._getOrReturnCtx($);return K(W,{code:O.invalid_type,expected:z.never,received:W.parsedType}),L}}t.create=($)=>{return new t({typeName:R.ZodNever,...q($)})};class x$ extends b{_parse($){if(this._getType($)!==z.undefined){let J=this._getOrReturnCtx($);return K(J,{code:O.invalid_type,expected:z.void,received:J.parsedType}),L}return m($.data)}}x$.create=($)=>{return new x$({typeName:R.ZodVoid,...q($)})};class c extends b{_parse($){let{ctx:W,status:J}=this._processInputParams($),Q=this._def;if(W.parsedType!==z.array)return K(W,{code:O.invalid_type,expected:z.array,received:W.parsedType}),L;if(Q.exactLength!==null){let Y=W.data.length>Q.exactLength.value,_=W.data.length<Q.exactLength.value;if(Y||_)K(W,{code:Y?O.too_big:O.too_small,minimum:_?Q.exactLength.value:void 0,maximum:Y?Q.exactLength.value:void 0,type:"array",inclusive:!0,exact:!0,message:Q.exactLength.message}),J.dirty()}if(Q.minLength!==null){if(W.data.length<Q.minLength.value)K(W,{code:O.too_small,minimum:Q.minLength.value,type:"array",inclusive:!0,exact:!1,message:Q.minLength.message}),J.dirty()}if(Q.maxLength!==null){if(W.data.length>Q.maxLength.value)K(W,{code:O.too_big,maximum:Q.maxLength.value,type:"array",inclusive:!0,exact:!1,message:Q.maxLength.message}),J.dirty()}if(W.common.async)return Promise.all([...W.data].map((Y,_)=>{return Q.type._parseAsync(new i(W,Y,W.path,_))})).then((Y)=>{return y.mergeArray(J,Y)});let X=[...W.data].map((Y,_)=>{return Q.type._parseSync(new i(W,Y,W.path,_))});return y.mergeArray(J,X)}get element(){return this._def.type}min($,W){return new c({...this._def,minLength:{value:$,message:M.toString(W)}})}max($,W){return new c({...this._def,maxLength:{value:$,message:M.toString(W)}})}length($,W){return new c({...this._def,exactLength:{value:$,message:M.toString(W)}})}nonempty($){return this.min(1,$)}}c.create=($,W)=>{return new c({type:$,minLength:null,maxLength:null,exactLength:null,typeName:R.ZodArray,...q(W)})};function w$($){if($ instanceof T){let W={};for(let J in $.shape){let Q=$.shape[J];W[J]=d.create(w$(Q))}return new T({...$._def,shape:()=>W})}else if($ instanceof c)return new c({...$._def,type:w$($.element)});else if($ instanceof d)return d.create(w$($.unwrap()));else if($ instanceof Q$)return Q$.create(w$($.unwrap()));else if($ instanceof r)return r.create($.items.map((W)=>w$(W)));else return $}class T extends b{constructor(){super(...arguments);this._cached=null,this.nonstrict=this.passthrough,this.augment=this.extend}_getCached(){if(this._cached!==null)return this._cached;let $=this._def.shape(),W=k.objectKeys($);return this._cached={shape:$,keys:W},this._cached}_parse($){if(this._getType($)!==z.object){let H=this._getOrReturnCtx($);return K(H,{code:O.invalid_type,expected:z.object,received:H.parsedType}),L}let{status:J,ctx:Q}=this._processInputParams($),{shape:X,keys:Y}=this._getCached(),_=[];if(!(this._def.catchall instanceof t&&this._def.unknownKeys==="strip")){for(let H in Q.data)if(!Y.includes(H))_.push(H)}let G=[];for(let H of Y){let N=X[H],j=Q.data[H];G.push({key:{status:"valid",value:H},value:N._parse(new i(Q,j,Q.path,H)),alwaysSet:H in Q.data})}if(this._def.catchall instanceof t){let H=this._def.unknownKeys;if(H==="passthrough")for(let N of _)G.push({key:{status:"valid",value:N},value:{status:"valid",value:Q.data[N]}});else if(H==="strict"){if(_.length>0)K(Q,{code:O.unrecognized_keys,keys:_}),J.dirty()}else if(H==="strip");else throw Error("Internal ZodObject error: invalid unknownKeys value.")}else{let H=this._def.catchall;for(let N of _){let j=Q.data[N];G.push({key:{status:"valid",value:N},value:H._parse(new i(Q,j,Q.path,N)),alwaysSet:N in Q.data})}}if(Q.common.async)return Promise.resolve().then(async()=>{let H=[];for(let N of G){let j=await N.key,V=await N.value;H.push({key:j,value:V,alwaysSet:N.alwaysSet})}return H}).then((H)=>{return y.mergeObjectSync(J,H)});else return y.mergeObjectSync(J,G)}get shape(){return this._def.shape()}strict($){return M.errToObj,new T({...this._def,unknownKeys:"strict",...$!==void 0?{errorMap:(W,J)=>{let Q=this._def.errorMap?.(W,J).message??J.defaultError;if(W.code==="unrecognized_keys")return{message:M.errToObj($).message??Q};return{message:Q}}}:{}})}strip(){return new T({...this._def,unknownKeys:"strip"})}passthrough(){return new T({...this._def,unknownKeys:"passthrough"})}extend($){return new T({...this._def,shape:()=>({...this._def.shape(),...$})})}merge($){return new T({unknownKeys:$._def.unknownKeys,catchall:$._def.catchall,shape:()=>({...this._def.shape(),...$._def.shape()}),typeName:R.ZodObject})}setKey($,W){return this.augment({[$]:W})}catchall($){return new T({...this._def,catchall:$})}pick($){let W={};for(let J of k.objectKeys($))if($[J]&&this.shape[J])W[J]=this.shape[J];return new T({...this._def,shape:()=>W})}omit($){let W={};for(let J of k.objectKeys(this.shape))if(!$[J])W[J]=this.shape[J];return new T({...this._def,shape:()=>W})}deepPartial(){return w$(this)}partial($){let W={};for(let J of k.objectKeys(this.shape)){let Q=this.shape[J];if($&&!$[J])W[J]=Q;else W[J]=Q.optional()}return new T({...this._def,shape:()=>W})}required($){let W={};for(let J of k.objectKeys(this.shape))if($&&!$[J])W[J]=this.shape[J];else{let X=this.shape[J];while(X instanceof d)X=X._def.innerType;W[J]=X}return new T({...this._def,shape:()=>W})}keyof(){return aW(k.objectKeys(this.shape))}}T.create=($,W)=>{return new T({shape:()=>$,unknownKeys:"strip",catchall:t.create(),typeName:R.ZodObject,...q(W)})};T.strictCreate=($,W)=>{return new T({shape:()=>$,unknownKeys:"strict",catchall:t.create(),typeName:R.ZodObject,...q(W)})};T.lazycreate=($,W)=>{return new T({shape:$,unknownKeys:"strip",catchall:t.create(),typeName:R.ZodObject,...q(W)})};class F$ extends b{_parse($){let{ctx:W}=this._processInputParams($),J=this._def.options;function Q(X){for(let _ of X)if(_.result.status==="valid")return _.result;for(let _ of X)if(_.result.status==="dirty")return W.common.issues.push(..._.ctx.common.issues),_.result;let Y=X.map((_)=>new u(_.ctx.common.issues));return K(W,{code:O.invalid_union,unionErrors:Y}),L}if(W.common.async)return Promise.all(J.map(async(X)=>{let Y={...W,common:{...W.common,issues:[]},parent:null};return{result:await X._parseAsync({data:W.data,path:W.path,parent:Y}),ctx:Y}})).then(Q);else{let X=void 0,Y=[];for(let G of J){let H={...W,common:{...W.common,issues:[]},parent:null},N=G._parseSync({data:W.data,path:W.path,parent:H});if(N.status==="valid")return N;else if(N.status==="dirty"&&!X)X={result:N,ctx:H};if(H.common.issues.length)Y.push(H.common.issues)}if(X)return W.common.issues.push(...X.ctx.common.issues),X.result;let _=Y.map((G)=>new u(G));return K(W,{code:O.invalid_union,unionErrors:_}),L}}get options(){return this._def.options}}F$.create=($,W)=>{return new F$({options:$,typeName:R.ZodUnion,...q(W)})};var J$=($)=>{if($ instanceof k$)return J$($.schema);else if($ instanceof n)return J$($.innerType());else if($ instanceof E$)return[$.value];else if($ instanceof B$)return $.options;else if($ instanceof v$)return k.objectValues($.enum);else if($ instanceof T$)return J$($._def.innerType);else if($ instanceof q$)return[void 0];else if($ instanceof b$)return[null];else if($ instanceof d)return[void 0,...J$($.unwrap())];else if($ instanceof Q$)return[null,...J$($.unwrap())];else if($ instanceof WW)return J$($.unwrap());else if($ instanceof P$)return J$($.unwrap());else if($ instanceof C$)return J$($._def.innerType);else return[]};class $W extends b{_parse($){let{ctx:W}=this._processInputParams($);if(W.parsedType!==z.object)return K(W,{code:O.invalid_type,expected:z.object,received:W.parsedType}),L;let J=this.discriminator,Q=W.data[J],X=this.optionsMap.get(Q);if(!X)return K(W,{code:O.invalid_union_discriminator,options:Array.from(this.optionsMap.keys()),path:[J]}),L;if(W.common.async)return X._parseAsync({data:W.data,path:W.path,parent:W});else return X._parseSync({data:W.data,path:W.path,parent:W})}get discriminator(){return this._def.discriminator}get options(){return this._def.options}get optionsMap(){return this._def.optionsMap}static create($,W,J){let Q=new Map;for(let X of W){let Y=J$(X.shape[$]);if(!Y.length)throw Error(`A discriminator value for key \`${$}\` could not be extracted from all schema options`);for(let _ of Y){if(Q.has(_))throw Error(`Discriminator property ${String($)} has duplicate value ${String(_)}`);Q.set(_,X)}}return new $W({typeName:R.ZodDiscriminatedUnion,discriminator:$,options:W,optionsMap:Q,...q(J)})}}function TW($,W){let J=o($),Q=o(W);if($===W)return{valid:!0,data:$};else if(J===z.object&&Q===z.object){let X=k.objectKeys(W),Y=k.objectKeys($).filter((G)=>X.indexOf(G)!==-1),_={...$,...W};for(let G of Y){let H=TW($[G],W[G]);if(!H.valid)return{valid:!1};_[G]=H.data}return{valid:!0,data:_}}else if(J===z.array&&Q===z.array){if($.length!==W.length)return{valid:!1};let X=[];for(let Y=0;Y<$.length;Y++){let _=$[Y],G=W[Y],H=TW(_,G);if(!H.valid)return{valid:!1};X.push(H.data)}return{valid:!0,data:X}}else if(J===z.date&&Q===z.date&&+$===+W)return{valid:!0,data:$};else return{valid:!1}}class f$ extends b{_parse($){let{status:W,ctx:J}=this._processInputParams($),Q=(X,Y)=>{if(r$(X)||r$(Y))return L;let _=TW(X.value,Y.value);if(!_.valid)return K(J,{code:O.invalid_intersection_types}),L;if(e$(X)||e$(Y))W.dirty();return{status:W.value,value:_.data}};if(J.common.async)return Promise.all([this._def.left._parseAsync({data:J.data,path:J.path,parent:J}),this._def.right._parseAsync({data:J.data,path:J.path,parent:J})]).then(([X,Y])=>Q(X,Y));else return Q(this._def.left._parseSync({data:J.data,path:J.path,parent:J}),this._def.right._parseSync({data:J.data,path:J.path,parent:J}))}}f$.create=($,W,J)=>{return new f$({left:$,right:W,typeName:R.ZodIntersection,...q(J)})};class r extends b{_parse($){let{status:W,ctx:J}=this._processInputParams($);if(J.parsedType!==z.array)return K(J,{code:O.invalid_type,expected:z.array,received:J.parsedType}),L;if(J.data.length<this._def.items.length)return K(J,{code:O.too_small,minimum:this._def.items.length,inclusive:!0,exact:!1,type:"array"}),L;if(!this._def.rest&&J.data.length>this._def.items.length)K(J,{code:O.too_big,maximum:this._def.items.length,inclusive:!0,exact:!1,type:"array"}),W.dirty();let X=[...J.data].map((Y,_)=>{let G=this._def.items[_]||this._def.rest;if(!G)return null;return G._parse(new i(J,Y,J.path,_))}).filter((Y)=>!!Y);if(J.common.async)return Promise.all(X).then((Y)=>{return y.mergeArray(W,Y)});else return y.mergeArray(W,X)}get items(){return this._def.items}rest($){return new r({...this._def,rest:$})}}r.create=($,W)=>{if(!Array.isArray($))throw Error("You must pass an array of schemas to z.tuple([ ... ])");return new r({items:$,typeName:R.ZodTuple,rest:null,...q(W)})};class l$ extends b{get keySchema(){return this._def.keyType}get valueSchema(){return this._def.valueType}_parse($){let{status:W,ctx:J}=this._processInputParams($);if(J.parsedType!==z.object)return K(J,{code:O.invalid_type,expected:z.object,received:J.parsedType}),L;let Q=[],X=this._def.keyType,Y=this._def.valueType;for(let _ in J.data)Q.push({key:X._parse(new i(J,_,J.path,_)),value:Y._parse(new i(J,J.data[_],J.path,_)),alwaysSet:_ in J.data});if(J.common.async)return y.mergeObjectAsync(W,Q);else return y.mergeObjectSync(W,Q)}get element(){return this._def.valueType}static create($,W,J){if(W instanceof b)return new l$({keyType:$,valueType:W,typeName:R.ZodRecord,...q(J)});return new l$({keyType:p.create(),valueType:$,typeName:R.ZodRecord,...q(W)})}}class u$ extends b{get keySchema(){return this._def.keyType}get valueSchema(){return this._def.valueType}_parse($){let{status:W,ctx:J}=this._processInputParams($);if(J.parsedType!==z.map)return K(J,{code:O.invalid_type,expected:z.map,received:J.parsedType}),L;let Q=this._def.keyType,X=this._def.valueType,Y=[...J.data.entries()].map(([_,G],H)=>{return{key:Q._parse(new i(J,_,J.path,[H,"key"])),value:X._parse(new i(J,G,J.path,[H,"value"]))}});if(J.common.async){let _=new Map;return Promise.resolve().then(async()=>{for(let G of Y){let H=await G.key,N=await G.value;if(H.status==="aborted"||N.status==="aborted")return L;if(H.status==="dirty"||N.status==="dirty")W.dirty();_.set(H.value,N.value)}return{status:W.value,value:_}})}else{let _=new Map;for(let G of Y){let{key:H,value:N}=G;if(H.status==="aborted"||N.status==="aborted")return L;if(H.status==="dirty"||N.status==="dirty")W.dirty();_.set(H.value,N.value)}return{status:W.value,value:_}}}}u$.create=($,W,J)=>{return new u$({valueType:W,keyType:$,typeName:R.ZodMap,...q(J)})};class V$ extends b{_parse($){let{status:W,ctx:J}=this._processInputParams($);if(J.parsedType!==z.set)return K(J,{code:O.invalid_type,expected:z.set,received:J.parsedType}),L;let Q=this._def;if(Q.minSize!==null){if(J.data.size<Q.minSize.value)K(J,{code:O.too_small,minimum:Q.minSize.value,type:"set",inclusive:!0,exact:!1,message:Q.minSize.message}),W.dirty()}if(Q.maxSize!==null){if(J.data.size>Q.maxSize.value)K(J,{code:O.too_big,maximum:Q.maxSize.value,type:"set",inclusive:!0,exact:!1,message:Q.maxSize.message}),W.dirty()}let X=this._def.valueType;function Y(G){let H=new Set;for(let N of G){if(N.status==="aborted")return L;if(N.status==="dirty")W.dirty();H.add(N.value)}return{status:W.value,value:H}}let _=[...J.data.values()].map((G,H)=>X._parse(new i(J,G,J.path,H)));if(J.common.async)return Promise.all(_).then((G)=>Y(G));else return Y(_)}min($,W){return new V$({...this._def,minSize:{value:$,message:M.toString(W)}})}max($,W){return new V$({...this._def,maxSize:{value:$,message:M.toString(W)}})}size($,W){return this.min($,W).max($,W)}nonempty($){return this.min(1,$)}}V$.create=($,W)=>{return new V$({valueType:$,minSize:null,maxSize:null,typeName:R.ZodSet,...q(W)})};class L$ extends b{constructor(){super(...arguments);this.validate=this.implement}_parse($){let{ctx:W}=this._processInputParams($);if(W.parsedType!==z.function)return K(W,{code:O.invalid_type,expected:z.function,received:W.parsedType}),L;function J(_,G){return h$({data:_,path:W.path,errorMaps:[W.common.contextualErrorMap,W.schemaErrorMap,M$(),W$].filter((H)=>!!H),issueData:{code:O.invalid_arguments,argumentsError:G}})}function Q(_,G){return h$({data:_,path:W.path,errorMaps:[W.common.contextualErrorMap,W.schemaErrorMap,M$(),W$].filter((H)=>!!H),issueData:{code:O.invalid_return_type,returnTypeError:G}})}let X={errorMap:W.common.contextualErrorMap},Y=W.data;if(this._def.returns instanceof z$){let _=this;return m(async function(...G){let H=new u([]),N=await _._def.args.parseAsync(G,X).catch((D)=>{throw H.addIssue(J(G,D)),H}),j=await Reflect.apply(Y,this,N);return await _._def.returns._def.type.parseAsync(j,X).catch((D)=>{throw H.addIssue(Q(j,D)),H})})}else{let _=this;return m(function(...G){let H=_._def.args.safeParse(G,X);if(!H.success)throw new u([J(G,H.error)]);let N=Reflect.apply(Y,this,H.data),j=_._def.returns.safeParse(N,X);if(!j.success)throw new u([Q(N,j.error)]);return j.data})}}parameters(){return this._def.args}returnType(){return this._def.returns}args(...$){return new L$({...this._def,args:r.create($).rest(_$.create())})}returns($){return new L$({...this._def,returns:$})}implement($){return this.parse($)}strictImplement($){return this.parse($)}static create($,W,J){return new L$({args:$?$:r.create([]).rest(_$.create()),returns:W||_$.create(),typeName:R.ZodFunction,...q(J)})}}class k$ extends b{get schema(){return this._def.getter()}_parse($){let{ctx:W}=this._processInputParams($);return this._def.getter()._parse({data:W.data,path:W.path,parent:W})}}k$.create=($,W)=>{return new k$({getter:$,typeName:R.ZodLazy,...q(W)})};class E$ extends b{_parse($){if($.data!==this._def.value){let W=this._getOrReturnCtx($);return K(W,{received:W.data,code:O.invalid_literal,expected:this._def.value}),L}return{status:"valid",value:$.data}}get value(){return this._def.value}}E$.create=($,W)=>{return new E$({value:$,typeName:R.ZodLiteral,...q(W)})};function aW($,W){return new B$({values:$,typeName:R.ZodEnum,...q(W)})}class B$ extends b{_parse($){if(typeof $.data!=="string"){let W=this._getOrReturnCtx($),J=this._def.values;return K(W,{expected:k.joinValues(J),received:W.parsedType,code:O.invalid_type}),L}if(!this._cache)this._cache=new Set(this._def.values);if(!this._cache.has($.data)){let W=this._getOrReturnCtx($),J=this._def.values;return K(W,{received:W.data,code:O.invalid_enum_value,options:J}),L}return m($.data)}get options(){return this._def.values}get enum(){let $={};for(let W of this._def.values)$[W]=W;return $}get Values(){let $={};for(let W of this._def.values)$[W]=W;return $}get Enum(){let $={};for(let W of this._def.values)$[W]=W;return $}extract($,W=this._def){return B$.create($,{...this._def,...W})}exclude($,W=this._def){return B$.create(this.options.filter((J)=>!$.includes(J)),{...this._def,...W})}}B$.create=aW;class v$ extends b{_parse($){let W=k.getValidEnumValues(this._def.values),J=this._getOrReturnCtx($);if(J.parsedType!==z.string&&J.parsedType!==z.number){let Q=k.objectValues(W);return K(J,{expected:k.joinValues(Q),received:J.parsedType,code:O.invalid_type}),L}if(!this._cache)this._cache=new Set(k.getValidEnumValues(this._def.values));if(!this._cache.has($.data)){let Q=k.objectValues(W);return K(J,{received:J.data,code:O.invalid_enum_value,options:Q}),L}return m($.data)}get enum(){return this._def.values}}v$.create=($,W)=>{return new v$({values:$,typeName:R.ZodNativeEnum,...q(W)})};class z$ extends b{unwrap(){return this._def.type}_parse($){let{ctx:W}=this._processInputParams($);if(W.parsedType!==z.promise&&W.common.async===!1)return K(W,{code:O.invalid_type,expected:z.promise,received:W.parsedType}),L;let J=W.parsedType===z.promise?W.data:Promise.resolve(W.data);return m(J.then((Q)=>{return this._def.type.parseAsync(Q,{path:W.path,errorMap:W.common.contextualErrorMap})}))}}z$.create=($,W)=>{return new z$({type:$,typeName:R.ZodPromise,...q(W)})};class n extends b{innerType(){return this._def.schema}sourceType(){return this._def.schema._def.typeName===R.ZodEffects?this._def.schema.sourceType():this._def.schema}_parse($){let{status:W,ctx:J}=this._processInputParams($),Q=this._def.effect||null,X={addIssue:(Y)=>{if(K(J,Y),Y.fatal)W.abort();else W.dirty()},get path(){return J.path}};if(X.addIssue=X.addIssue.bind(X),Q.type==="preprocess"){let Y=Q.transform(J.data,X);if(J.common.async)return Promise.resolve(Y).then(async(_)=>{if(W.value==="aborted")return L;let G=await this._def.schema._parseAsync({data:_,path:J.path,parent:J});if(G.status==="aborted")return L;if(G.status==="dirty")return j$(G.value);if(W.value==="dirty")return j$(G.value);return G});else{if(W.value==="aborted")return L;let _=this._def.schema._parseSync({data:Y,path:J.path,parent:J});if(_.status==="aborted")return L;if(_.status==="dirty")return j$(_.value);if(W.value==="dirty")return j$(_.value);return _}}if(Q.type==="refinement"){let Y=(_)=>{let G=Q.refinement(_,X);if(J.common.async)return Promise.resolve(G);if(G instanceof Promise)throw Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");return _};if(J.common.async===!1){let _=this._def.schema._parseSync({data:J.data,path:J.path,parent:J});if(_.status==="aborted")return L;if(_.status==="dirty")W.dirty();return Y(_.value),{status:W.value,value:_.value}}else return this._def.schema._parseAsync({data:J.data,path:J.path,parent:J}).then((_)=>{if(_.status==="aborted")return L;if(_.status==="dirty")W.dirty();return Y(_.value).then(()=>{return{status:W.value,value:_.value}})})}if(Q.type==="transform")if(J.common.async===!1){let Y=this._def.schema._parseSync({data:J.data,path:J.path,parent:J});if(!Y$(Y))return L;let _=Q.transform(Y.value,X);if(_ instanceof Promise)throw Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");return{status:W.value,value:_}}else return this._def.schema._parseAsync({data:J.data,path:J.path,parent:J}).then((Y)=>{if(!Y$(Y))return L;return Promise.resolve(Q.transform(Y.value,X)).then((_)=>({status:W.value,value:_}))});k.assertNever(Q)}}n.create=($,W,J)=>{return new n({schema:$,typeName:R.ZodEffects,effect:W,...q(J)})};n.createWithPreprocess=($,W,J)=>{return new n({schema:W,effect:{type:"preprocess",transform:$},typeName:R.ZodEffects,...q(J)})};class d extends b{_parse($){if(this._getType($)===z.undefined)return m(void 0);return this._def.innerType._parse($)}unwrap(){return this._def.innerType}}d.create=($,W)=>{return new d({innerType:$,typeName:R.ZodOptional,...q(W)})};class Q$ extends b{_parse($){if(this._getType($)===z.null)return m(null);return this._def.innerType._parse($)}unwrap(){return this._def.innerType}}Q$.create=($,W)=>{return new Q$({innerType:$,typeName:R.ZodNullable,...q(W)})};class T$ extends b{_parse($){let{ctx:W}=this._processInputParams($),J=W.data;if(W.parsedType===z.undefined)J=this._def.defaultValue();return this._def.innerType._parse({data:J,path:W.path,parent:W})}removeDefault(){return this._def.innerType}}T$.create=($,W)=>{return new T$({innerType:$,typeName:R.ZodDefault,defaultValue:typeof W.default==="function"?W.default:()=>W.default,...q(W)})};class C$ extends b{_parse($){let{ctx:W}=this._processInputParams($),J={...W,common:{...W.common,issues:[]}},Q=this._def.innerType._parse({data:J.data,path:J.path,parent:{...J}});if(S$(Q))return Q.then((X)=>{return{status:"valid",value:X.status==="valid"?X.value:this._def.catchValue({get error(){return new u(J.common.issues)},input:J.data})}});else return{status:"valid",value:Q.status==="valid"?Q.value:this._def.catchValue({get error(){return new u(J.common.issues)},input:J.data})}}removeCatch(){return this._def.innerType}}C$.create=($,W)=>{return new C$({innerType:$,typeName:R.ZodCatch,catchValue:typeof W.catch==="function"?W.catch:()=>W.catch,...q(W)})};class p$ extends b{_parse($){if(this._getType($)!==z.nan){let J=this._getOrReturnCtx($);return K(J,{code:O.invalid_type,expected:z.nan,received:J.parsedType}),L}return{status:"valid",value:$.data}}}p$.create=($)=>{return new p$({typeName:R.ZodNaN,...q($)})};var J8=Symbol("zod_brand");class WW extends b{_parse($){let{ctx:W}=this._processInputParams($),J=W.data;return this._def.type._parse({data:J,path:W.path,parent:W})}unwrap(){return this._def.type}}class c$ extends b{_parse($){let{status:W,ctx:J}=this._processInputParams($);if(J.common.async)return(async()=>{let X=await this._def.in._parseAsync({data:J.data,path:J.path,parent:J});if(X.status==="aborted")return L;if(X.status==="dirty")return W.dirty(),j$(X.value);else return this._def.out._parseAsync({data:X.value,path:J.path,parent:J})})();else{let Q=this._def.in._parseSync({data:J.data,path:J.path,parent:J});if(Q.status==="aborted")return L;if(Q.status==="dirty")return W.dirty(),{status:"dirty",value:Q.value};else return this._def.out._parseSync({data:Q.value,path:J.path,parent:J})}}static create($,W){return new c$({in:$,out:W,typeName:R.ZodPipeline})}}class P$ extends b{_parse($){let W=this._def.innerType._parse($),J=(Q)=>{if(Y$(Q))Q.value=Object.freeze(Q.value);return Q};return S$(W)?W.then((Q)=>J(Q)):J(W)}unwrap(){return this._def.innerType}}P$.create=($,W)=>{return new P$({innerType:$,typeName:R.ZodReadonly,...q(W)})};function cW($,W){let J=typeof $==="function"?$(W):typeof $==="string"?{message:$}:$;return typeof J==="string"?{message:J}:J}function sW($,W={},J){if($)return O$.create().superRefine((Q,X)=>{let Y=$(Q);if(Y instanceof Promise)return Y.then((_)=>{if(!_){let G=cW(W,Q),H=G.fatal??J??!0;X.addIssue({code:"custom",...G,fatal:H})}});if(!Y){let _=cW(W,Q),G=_.fatal??J??!0;X.addIssue({code:"custom",..._,fatal:G})}return});return O$.create()}var Q8={object:T.lazycreate},R;(function($){$.ZodString="ZodString",$.ZodNumber="ZodNumber",$.ZodNaN="ZodNaN",$.ZodBigInt="ZodBigInt",$.ZodBoolean="ZodBoolean",$.ZodDate="ZodDate",$.ZodSymbol="ZodSymbol",$.ZodUndefined="ZodUndefined",$.ZodNull="ZodNull",$.ZodAny="ZodAny",$.ZodUnknown="ZodUnknown",$.ZodNever="ZodNever",$.ZodVoid="ZodVoid",$.ZodArray="ZodArray",$.ZodObject="ZodObject",$.ZodUnion="ZodUnion",$.ZodDiscriminatedUnion="ZodDiscriminatedUnion",$.ZodIntersection="ZodIntersection",$.ZodTuple="ZodTuple",$.ZodRecord="ZodRecord",$.ZodMap="ZodMap",$.ZodSet="ZodSet",$.ZodFunction="ZodFunction",$.ZodLazy="ZodLazy",$.ZodLiteral="ZodLiteral",$.ZodEnum="ZodEnum",$.ZodEffects="ZodEffects",$.ZodNativeEnum="ZodNativeEnum",$.ZodOptional="ZodOptional",$.ZodNullable="ZodNullable",$.ZodDefault="ZodDefault",$.ZodCatch="ZodCatch",$.ZodPromise="ZodPromise",$.ZodBranded="ZodBranded",$.ZodPipeline="ZodPipeline",$.ZodReadonly="ZodReadonly"})(R||(R={}));var X8=($,W={message:`Input not instance of ${$.name}`})=>sW((J)=>J instanceof $,W),oW=p.create,tW=G$.create,Y8=p$.create,_8=H$.create,rW=R$.create,G8=A$.create,H8=m$.create,B8=q$.create,N8=b$.create,j8=O$.create,A8=_$.create,O8=t.create,V8=x$.create,z8=c.create,K8=T.create,U8=T.strictCreate,D8=F$.create,M8=$W.create,S8=f$.create,w8=r.create,L8=l$.create,R8=u$.create,q8=V$.create,b8=L$.create,F8=k$.create,f8=E$.create,k8=B$.create,E8=v$.create,v8=z$.create,T8=n.create,C8=d.create,P8=Q$.create,I8=n.createWithPreprocess,Z8=c$.create,y8=()=>oW().optional(),g8=()=>tW().optional(),h8=()=>rW().optional(),m8={string:($)=>p.create({...$,coerce:!0}),number:($)=>G$.create({...$,coerce:!0}),boolean:($)=>R$.create({...$,coerce:!0}),bigint:($)=>H$.create({...$,coerce:!0}),date:($)=>A$.create({...$,coerce:!0})};var x8=L;var Z9=U.object({sessionId:U.string().optional(),processId:U.string().optional(),timeoutMs:U.number().positive().optional(),env:U.record(U.string()).optional(),cwd:U.string().optional(),encoding:U.string().optional(),autoCleanup:U.boolean().optional()}),eW=U.object({command:U.string().min(1,"Command cannot be empty"),sessionId:U.string().optional(),background:U.boolean().optional(),timeoutMs:U.number().positive().optional(),env:U.record(U.string()).optional(),cwd:U.string().optional()}),l8=U.object({path:U.string().min(1,"Path cannot be empty"),encoding:U.string().optional(),sessionId:U.string().optional()}),u8=U.object({path:U.string().min(1,"Path cannot be empty"),content:U.string(),encoding:U.string().optional(),sessionId:U.string().optional()}),p8=U.object({path:U.string().min(1,"Path cannot be empty"),sessionId:U.string().optional()}),c8=U.object({oldPath:U.string().min(1,"Old path cannot be empty"),newPath:U.string().min(1,"New path cannot be empty"),sessionId:U.string().optional()}),d8=U.object({sourcePath:U.string().min(1,"Source path cannot be empty"),destinationPath:U.string().min(1,"Destination path cannot be empty"),sessionId:U.string().optional()}),i8=U.object({path:U.string().min(1,"Path cannot be empty"),recursive:U.boolean().optional(),sessionId:U.string().optional()}),n8=U.object({path:U.string().min(1,"Path cannot be empty"),options:U.object({recursive:U.boolean().optional(),includeHidden:U.boolean().optional()}).optional(),sessionId:U.string().optional()}),$3=U.object({command:U.string().min(1,"Command cannot be empty"),sessionId:U.string().optional(),processId:U.string().optional(),timeoutMs:U.number().positive().optional(),env:U.record(U.string()).optional(),cwd:U.string().optional(),encoding:U.string().optional(),autoCleanup:U.boolean().optional()}),W3=U.object({port:U.number().int().min(1).max(65535,"Port must be between 1 and 65535"),name:U.string().optional()}),J3=U.object({repoUrl:U.string().min(1,"Repository URL cannot be empty"),branch:U.string().optional(),targetDir:U.string().optional(),sessionId:U.string().optional()}),Q3={read:l8,write:u8,delete:p8,rename:c8,move:d8,mkdir:i8,listFiles:n8};class CW{validateExecuteRequest($){let W=eW.safeParse($);if(!W.success)return{isValid:!1,errors:W.error.issues.map((J)=>({field:J.path.join(".")||"request",message:J.message,code:J.code}))};return{isValid:!0,data:W.data,errors:[]}}validateFileRequest($,W){let Q=Q3[W].safeParse($);if(!Q.success)return{isValid:!1,errors:Q.error.issues.map((X)=>({field:X.path.join(".")||"request",message:X.message,code:X.code}))};return{isValid:!0,data:Q.data,errors:[]}}validateProcessRequest($){let W=$3.safeParse($);if(!W.success)return{isValid:!1,errors:W.error.issues.map((J)=>({field:J.path.join(".")||"request",message:J.message,code:J.code}))};return{isValid:!0,data:W.data,errors:[]}}validatePortRequest($){let W=W3.safeParse($);if(!W.success)return{isValid:!1,errors:W.error.issues.map((J)=>({field:J.path.join(".")||"request",message:J.message,code:J.code}))};return{isValid:!0,data:W.data,errors:[]}}validateGitRequest($){let W=J3.safeParse($);if(!W.success)return{isValid:!1,errors:W.error.issues.map((J)=>({field:J.path.join(".")||"request",message:J.message,code:J.code}))};return{isValid:!0,data:W.data,errors:[]}}}class JW{dependencies={};initialized=!1;get($){if(!this.initialized)throw Error("Container not initialized. Call initialize() first.");let W=this.dependencies[$];if(!W)throw Error(`Dependency '${$}' not found. Make sure to initialize the container.`);return W}set($,W){this.dependencies[$]=W}async initialize(){if(this.initialized)return;let $=N$({component:"container"}),W=new a$($),J=new zW(W),Q=new CW,X=new FW($),Y=new LW,_=new kW($),G=new y$($),H=new bW(X,$,_),N=new UW(J,$,_),j=new RW(Y,J,$),V=new MW(J,G,_),D=new SW($),S=new AW(_,$),E=new YW(H,$),w=new _W(N,$),F=new jW(H,$),x=new NW(j,$),v=new GW(V,G),P=new HW(D,$),C=new BW($),A=new OW,l=new VW($);this.dependencies={processService:H,fileService:N,portService:j,gitService:V,interpreterService:D,logger:$,security:W,validator:Q,executeHandler:E,fileHandler:w,processHandler:F,portHandler:x,gitHandler:v,interpreterHandler:P,sessionHandler:S,miscHandler:C,corsMiddleware:A,loggingMiddleware:l},this.initialized=!0}isInitialized(){return this.initialized}}class PW{routes=[];globalMiddleware=[];logger;constructor($){this.logger=$}register($){this.routes.push($)}use($){this.globalMiddleware.push($)}validateHttpMethod($){if(["GET","POST","PUT","DELETE","OPTIONS"].includes($))return $;throw Error(`Unsupported HTTP method: ${$}`)}async route($){let W=this.validateHttpMethod($.method),J=new URL($.url).pathname,Q=this.matchRoute(W,J);if(!Q)return this.logger.debug("No route found",{method:W,pathname:J}),this.createNotFoundResponse();let X={sessionId:this.extractSessionId($),corsHeaders:this.getCorsHeaders(),requestId:this.generateRequestId(),timestamp:new Date};try{let Y=[...this.globalMiddleware,...Q.middleware||[]];return await this.executeMiddlewareChain(Y,$,X,Q.handler)}catch(Y){return this.logger.error("Error handling request",Y,{method:W,pathname:J,requestId:X.requestId}),this.createErrorResponse(Y instanceof Error?Y:Error("Unknown error"))}}matchRoute($,W){for(let J of this.routes)if(J.method===$&&this.pathMatches(J.path,W))return J;return null}pathMatches($,W){if($===W)return!0;let J=$.split("/"),Q=W.split("/");if(J.length!==Q.length)return!1;return J.every((X,Y)=>{if(X.startsWith("{")&&X.endsWith("}"))return!0;return X===Q[Y]})}async executeMiddlewareChain($,W,J,Q){let X=0,Y=async()=>{if(X>=$.length)return await Q(W,J);let _=$[X];return X++,await _.handle(W,J,Y)};return await Y()}extractSessionId($){let W=$.headers.get("Authorization");if(W?.startsWith("Bearer "))return W.substring(7);let J=$.headers.get("X-Session-Id");if(J)return J;try{let Q=new URL($.url),X=Q.searchParams.get("session")||Q.searchParams.get("sessionId");if(X)return X}catch{}return}getCorsHeaders(){return{"Access-Control-Allow-Headers":"Content-Type, Authorization, X-Session-Id","Access-Control-Allow-Methods":"GET, POST, PUT, DELETE, OPTIONS","Access-Control-Allow-Origin":"*"}}generateRequestId(){return`req_${Date.now()}_${Math.random().toString(36).substring(2,8)}`}createNotFoundResponse(){let $={code:B.UNKNOWN_ERROR,message:"The requested endpoint was not found",context:{},httpStatus:404,timestamp:new Date().toISOString()};return new Response(JSON.stringify($),{status:404,headers:{"Content-Type":"application/json",...this.getCorsHeaders()}})}createErrorResponse($){let W={code:B.INTERNAL_ERROR,message:$.message,context:{stack:$.stack},httpStatus:500,timestamp:new Date().toISOString()};return new Response(JSON.stringify(W),{status:500,headers:{"Content-Type":"application/json",...this.getCorsHeaders()}})}}function X3($,W){$.register({method:"POST",path:"/api/session/create",handler:async(J,Q)=>W.get("sessionHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"GET",path:"/api/session/list",handler:async(J,Q)=>W.get("sessionHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"POST",path:"/api/session/delete",handler:async(J,Q)=>W.get("sessionHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"POST",path:"/api/execute",handler:async(J,Q)=>W.get("executeHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"POST",path:"/api/execute/stream",handler:async(J,Q)=>W.get("executeHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"POST",path:"/api/read",handler:async(J,Q)=>W.get("fileHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"POST",path:"/api/read/stream",handler:async(J,Q)=>W.get("fileHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"POST",path:"/api/write",handler:async(J,Q)=>W.get("fileHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"POST",path:"/api/delete",handler:async(J,Q)=>W.get("fileHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"POST",path:"/api/rename",handler:async(J,Q)=>W.get("fileHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"POST",path:"/api/move",handler:async(J,Q)=>W.get("fileHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"POST",path:"/api/mkdir",handler:async(J,Q)=>W.get("fileHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"POST",path:"/api/list-files",handler:async(J,Q)=>W.get("fileHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"POST",path:"/api/exists",handler:async(J,Q)=>W.get("fileHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"POST",path:"/api/expose-port",handler:async(J,Q)=>W.get("portHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"GET",path:"/api/exposed-ports",handler:async(J,Q)=>W.get("portHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"DELETE",path:"/api/exposed-ports/{port}",handler:async(J,Q)=>W.get("portHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"POST",path:"/api/process/start",handler:async(J,Q)=>W.get("processHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"GET",path:"/api/process/list",handler:async(J,Q)=>W.get("processHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"DELETE",path:"/api/process/kill-all",handler:async(J,Q)=>W.get("processHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"GET",path:"/api/process/{id}",handler:async(J,Q)=>W.get("processHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"DELETE",path:"/api/process/{id}",handler:async(J,Q)=>W.get("processHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"GET",path:"/api/process/{id}/logs",handler:async(J,Q)=>W.get("processHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"GET",path:"/api/process/{id}/stream",handler:async(J,Q)=>W.get("processHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"POST",path:"/api/git/checkout",handler:async(J,Q)=>W.get("gitHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"GET",path:"/api/interpreter/health",handler:async(J,Q)=>W.get("interpreterHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"POST",path:"/api/contexts",handler:async(J,Q)=>W.get("interpreterHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"GET",path:"/api/contexts",handler:async(J,Q)=>W.get("interpreterHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"DELETE",path:"/api/contexts/{id}",handler:async(J,Q)=>W.get("interpreterHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"POST",path:"/api/execute/code",handler:async(J,Q)=>W.get("interpreterHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"GET",path:"/proxy/{port}",handler:async(J,Q)=>W.get("portHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"POST",path:"/proxy/{port}",handler:async(J,Q)=>W.get("portHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"PUT",path:"/proxy/{port}",handler:async(J,Q)=>W.get("portHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"DELETE",path:"/proxy/{port}",handler:async(J,Q)=>W.get("portHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"GET",path:"/",handler:async(J,Q)=>W.get("miscHandler").handle(J,Q)}),$.register({method:"GET",path:"/api/ping",handler:async(J,Q)=>W.get("miscHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"GET",path:"/api/commands",handler:async(J,Q)=>W.get("miscHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]}),$.register({method:"GET",path:"/api/version",handler:async(J,Q)=>W.get("miscHandler").handle(J,Q),middleware:[W.get("loggingMiddleware")]})}var I$=N$({component:"container"});async function s8(){let $=new JW;await $.initialize();let W=new PW(I$);return W.use($.get("corsMiddleware")),X3(W,$),{fetch:(J)=>W.route(J)}}var o8=await s8(),t8=a8({idleTimeout:255,fetch:o8.fetch,hostname:"0.0.0.0",port:3000,websocket:{async message(){}}});I$.info("Container server started",{port:t8.port,hostname:"0.0.0.0"});process.on("SIGTERM",async()=>{I$.info("Received SIGTERM, shutting down gracefully");let $=new JW;if($.isInitialized())try{let W=$.get("processService"),J=$.get("portService");await W.destroy(),J.destroy(),I$.info("Services cleaned up successfully")}catch(W){I$.error("Error during cleanup",W instanceof Error?W:Error(String(W)))}process.exit(0)});process.on("SIGINT",async()=>{I$.info("Received SIGINT, shutting down gracefully"),process.emit("SIGTERM")});

//# debugId=7969ADDA3881432D64756E2164756E21
